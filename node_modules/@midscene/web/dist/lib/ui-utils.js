"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/common/ui-utils.ts
var ui_utils_exports = {};
__export(ui_utils_exports, {
  getKeyCommands: () => getKeyCommands,
  limitOpenNewTabScript: () => limitOpenNewTabScript,
  paramStr: () => paramStr,
  typeStr: () => typeStr
});
module.exports = __toCommonJS(ui_utils_exports);
function typeStr(task) {
  return task.subType ? `${task.type} / ${task.subType || ""}` : task.type;
}
function getKeyCommands(value) {
  const keys = Array.isArray(value) ? value : [value];
  return keys.reduce((acc, k) => {
    const includeMeta = keys.includes("Meta") || keys.includes("Control");
    if (includeMeta && (k === "a" || k === "A")) {
      return acc.concat([{ key: k, command: "SelectAll" }]);
    }
    if (includeMeta && (k === "c" || k === "C")) {
      return acc.concat([{ key: k, command: "Copy" }]);
    }
    if (includeMeta && (k === "v" || k === "V")) {
      return acc.concat([{ key: k, command: "Paste" }]);
    }
    return acc.concat([{ key: k }]);
  }, []);
}
function paramStr(task) {
  let value;
  if (task.type === "Planning") {
    value = task?.param?.userInstruction;
  }
  if (task.type === "Insight") {
    value = task?.param?.prompt || task?.param?.id || task?.param?.dataDemand || task?.param?.assertion;
  }
  if (task.type === "Action") {
    const sleepMs = task?.param?.timeMs;
    const scrollType = task?.param?.scrollType;
    if (sleepMs) {
      value = `${sleepMs}ms`;
    } else if (scrollType) {
      const scrollDirection = task?.param?.direction;
      const scrollDistance = task?.param?.distance;
      value = `${scrollDirection || "down"}, ${scrollType || "once"}, ${scrollDistance || "distance-not-set"}`;
    } else {
      value = task?.param?.value || task?.param?.scrollType;
    }
    if (!value) {
      value = task.thought;
    }
  }
  if (typeof value === "undefined")
    return "";
  return typeof value === "string" ? value : JSON.stringify(value, void 0, 2);
}
var limitOpenNewTabScript = `
if (!window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__) {
  window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__ = true;

  // Intercept the window.open method (only once)
  window.open = function(url) {
    console.log('Blocked window.open:', url);
    window.location.href = url;
    return null;
  };

  // Block all a tag clicks with target="_blank" (only once)
  document.addEventListener('click', function(e) {
    const target = e.target.closest('a');
    if (target && target.target === '_blank') {
      e.preventDefault();
      console.log('Blocked new tab:', target.href);
      window.location.href = target.href;
      target.removeAttribute('target');
    }
  }, true);
}
`;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getKeyCommands,
  limitOpenNewTabScript,
  paramStr,
  typeStr
});

//# sourceMappingURL=ui-utils.js.map