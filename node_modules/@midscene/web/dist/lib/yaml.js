"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/yaml/index.ts
var yaml_exports = {};
__export(yaml_exports, {
  ScriptPlayer: () => ScriptPlayer,
  buildYaml: () => buildYaml,
  flowItemBrief: () => flowItemBrief,
  parseYamlScript: () => parseYamlScript
});
module.exports = __toCommonJS(yaml_exports);

// src/yaml/player.ts
var import_node_fs = require("fs");
var import_node_path = require("path");
var import_utils = require("@midscene/shared/utils");
var ScriptPlayer = class {
  constructor(script, setupAgent, onTaskStatusChange) {
    this.script = script;
    this.setupAgent = setupAgent;
    this.onTaskStatusChange = onTaskStatusChange;
    this.taskStatusList = [];
    this.status = "init";
    this.unnamedResultIndex = 0;
    this.pageAgent = null;
    this.result = {};
    this.output = script.target?.output;
    this.taskStatusList = (script.tasks || []).map((task, taskIndex) => ({
      ...task,
      index: taskIndex,
      status: "init",
      totalSteps: task.flow?.length || 0
    }));
  }
  setPlayerStatus(status, error) {
    this.status = status;
    this.errorInSetup = error;
  }
  notifyCurrentTaskStatusChange(taskIndex) {
    const taskIndexToNotify = typeof taskIndex === "number" ? taskIndex : this.currentTaskIndex;
    if (typeof taskIndexToNotify !== "number") {
      return;
    }
    const taskStatus = this.taskStatusList[taskIndexToNotify];
    if (this.onTaskStatusChange) {
      this.onTaskStatusChange(taskStatus);
    }
  }
  async setTaskStatus(index, statusValue, error) {
    this.taskStatusList[index].status = statusValue;
    if (error) {
      this.taskStatusList[index].error = error;
    }
    this.notifyCurrentTaskStatusChange(index);
  }
  setTaskIndex(taskIndex) {
    this.currentTaskIndex = taskIndex;
  }
  flushResult() {
    if (Object.keys(this.result).length && this.output) {
      const output = (0, import_node_path.join)(process.cwd(), this.output);
      const outputDir = (0, import_node_path.dirname)(output);
      if (!(0, import_node_fs.existsSync)(outputDir)) {
        (0, import_node_fs.mkdirSync)(outputDir, { recursive: true });
      }
      (0, import_node_fs.writeFileSync)(output, JSON.stringify(this.result, void 0, 2));
    }
  }
  async playTask(taskStatus, agent) {
    const { flow } = taskStatus;
    (0, import_utils.assert)(flow, "missing flow in task");
    for (const flowItemIndex in flow) {
      const currentStep = Number.parseInt(flowItemIndex, 10);
      taskStatus.currentStep = currentStep;
      const flowItem = flow[flowItemIndex];
      if (flowItem.aiAction || flowItem.ai) {
        const actionTask = flowItem;
        const prompt = actionTask.aiAction || actionTask.ai;
        (0, import_utils.assert)(prompt, "missing prompt for ai (aiAction)");
        (0, import_utils.assert)(
          typeof prompt === "string",
          "prompt for aiAction must be a string"
        );
        await agent.aiAction(prompt);
      } else if (flowItem.aiAssert) {
        const assertTask = flowItem;
        const prompt = assertTask.aiAssert;
        (0, import_utils.assert)(prompt, "missing prompt for aiAssert");
        (0, import_utils.assert)(
          typeof prompt === "string",
          "prompt for aiAssert must be a string"
        );
        await agent.aiAssert(prompt);
      } else if (flowItem.aiQuery) {
        const queryTask = flowItem;
        const prompt = queryTask.aiQuery;
        (0, import_utils.assert)(prompt, "missing prompt for aiQuery");
        (0, import_utils.assert)(
          typeof prompt === "string",
          "prompt for aiQuery must be a string"
        );
        const queryResult = await agent.aiQuery(prompt);
        const resultKey = queryTask.name || this.unnamedResultIndex++;
        if (this.result[resultKey]) {
          console.warn(
            `result key ${resultKey} already exists, will overwrite`
          );
        }
        this.result[resultKey] = queryResult;
        this.flushResult();
      } else if (flowItem.aiWaitFor) {
        const waitForTask = flowItem;
        const prompt = waitForTask.aiWaitFor;
        (0, import_utils.assert)(prompt, "missing prompt for aiWaitFor");
        (0, import_utils.assert)(
          typeof prompt === "string",
          "prompt for aiWaitFor must be a string"
        );
        const timeout = waitForTask.timeout;
        await agent.aiWaitFor(prompt, { timeoutMs: timeout });
      } else if (flowItem.sleep) {
        const sleepTask = flowItem;
        const ms = sleepTask.sleep;
        let msNumber = ms;
        if (typeof ms === "string") {
          msNumber = Number.parseInt(ms, 10);
        }
        (0, import_utils.assert)(
          msNumber && msNumber > 0,
          `ms for sleep must be greater than 0, but got ${ms}`
        );
        await new Promise((resolve) => setTimeout(resolve, msNumber));
      } else {
        throw new Error(`unknown flowItem: ${JSON.stringify(flowItem)}`);
      }
    }
    this.reportFile = agent.reportFile;
  }
  async run() {
    const { target, tasks } = this.script;
    this.setPlayerStatus("running");
    let agent = null;
    let freeFn = [];
    try {
      const { agent: newAgent, freeFn: newFreeFn } = await this.setupAgent(target);
      agent = newAgent;
      freeFn = newFreeFn;
    } catch (e) {
      this.setPlayerStatus("error", e);
      return;
    }
    this.pageAgent = agent;
    let taskIndex = 0;
    this.setPlayerStatus("running");
    let errorFlag = false;
    while (taskIndex < tasks.length) {
      const taskStatus = this.taskStatusList[taskIndex];
      this.setTaskStatus(taskIndex, "running");
      this.setTaskIndex(taskIndex);
      try {
        await this.playTask(taskStatus, this.pageAgent);
        this.setTaskStatus(taskIndex, "done");
      } catch (e) {
        this.setTaskStatus(taskIndex, "error", e);
        if (taskStatus.continueOnError) {
        } else {
          this.reportFile = agent.reportFile;
          errorFlag = true;
          break;
        }
      }
      this.reportFile = agent.reportFile;
      taskIndex++;
    }
    if (errorFlag) {
      this.setPlayerStatus("error");
    } else {
      this.setPlayerStatus("done");
    }
    for (const fn of freeFn) {
      try {
        await fn.fn();
      } catch (e) {
      }
    }
  }
};

// src/yaml/builder.ts
var import_js_yaml = __toESM(require("js-yaml"));
function buildYaml(env, tasks) {
  const result = {
    target: env,
    tasks
  };
  return import_js_yaml.default.dump(result, {
    indent: 2
  });
}

// src/yaml/utils.ts
var import_utils2 = require("@midscene/shared/utils");
var import_js_yaml2 = __toESM(require("js-yaml"));
function interpolateEnvVars(content) {
  return content.replace(/\$\{([^}]+)\}/g, (_, envVar) => {
    const value = process.env[envVar.trim()];
    if (value === void 0) {
      throw new Error(`Environment variable "${envVar.trim()}" is not defined`);
    }
    return value;
  });
}
function parseYamlScript(content, filePath, ignoreCheckingTarget) {
  const interpolatedContent = interpolateEnvVars(content);
  const obj = import_js_yaml2.default.load(interpolatedContent);
  const pathTip = filePath ? `, failed to load ${filePath}` : "";
  if (!ignoreCheckingTarget) {
    (0, import_utils2.assert)(
      obj.target,
      `property "target" is required in yaml script${pathTip}`
    );
    (0, import_utils2.assert)(
      typeof obj.target === "object",
      `property "target" must be an object${pathTip}`
    );
  }
  (0, import_utils2.assert)(obj.tasks, `property "tasks" is required in yaml script ${pathTip}`);
  (0, import_utils2.assert)(
    Array.isArray(obj.tasks),
    `property "tasks" must be an array in yaml script, but got ${obj.tasks}`
  );
  return obj;
}
var flowItemBrief = (flowItem) => {
  if (!flowItem) {
    return "";
  }
  const sliceText = (text) => {
    const lengthLimit = 60;
    if (text && text.length > lengthLimit) {
      return `${text.slice(0, lengthLimit)}...`;
    }
    return text || "";
  };
  if (flowItem.aiAction || flowItem.ai) {
    const lastTip = (flowItem.aiActionProgressTips || []).at(-1);
    return `aiAction: ${sliceText(
      lastTip || flowItem.aiAction || flowItem.ai
    )}`;
  }
  if (flowItem.aiAssert) {
    return `aiAssert: ${sliceText(
      flowItem.aiAssert
    )}`;
  }
  if (flowItem.aiQuery) {
    return `aiQuery: ${sliceText(flowItem.aiQuery)}`;
  }
  if (flowItem.aiWaitFor) {
    return `aiWaitFor: ${sliceText(
      flowItem.aiWaitFor
    )}`;
  }
  if (flowItem.sleep) {
    return `sleep: ${flowItem.sleep}`;
  }
  return "";
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ScriptPlayer,
  buildYaml,
  flowItemBrief,
  parseYamlScript
});

//# sourceMappingURL=yaml.js.map