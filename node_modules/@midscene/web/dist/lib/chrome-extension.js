"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/chrome-extension/index.ts
var chrome_extension_exports = {};
__export(chrome_extension_exports, {
  ChromeExtensionProxyPage: () => ChromeExtensionProxyPage,
  ChromeExtensionProxyPageAgent: () => ChromeExtensionProxyPageAgent,
  ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED: () => ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED
});
module.exports = __toCommonJS(chrome_extension_exports);

// src/common/utils.ts
var import_env = require("@midscene/core/env");
var import_utils = require("@midscene/core/utils");
var import_constants = require("@midscene/shared/constants");
var import_extractor = require("@midscene/shared/extractor");
var import_img = require("@midscene/shared/img");
var import_utils2 = require("@midscene/shared/utils");
var import_dayjs = __toESM(require("dayjs"));

// src/web-element.ts
var WebElementInfo = class {
  constructor({
    content,
    rect,
    // page,
    locator,
    id,
    attributes,
    indexId
  }) {
    this.content = content;
    this.rect = rect;
    this.center = [
      Math.floor(rect.left + rect.width / 2),
      Math.floor(rect.top + rect.height / 2)
    ];
    this.locator = locator;
    this.id = id;
    this.attributes = attributes;
    this.indexId = indexId;
  }
};

// src/common/utils.ts
async function parseContextFromWebPage(page, _opt) {
  (0, import_utils2.assert)(page, "page is required");
  if (page._forceUsePageContext) {
    return await page._forceUsePageContext();
  }
  const url = await page.url();
  (0, import_utils.uploadTestInfoToServer)({ testUrl: url });
  let screenshotBase64;
  let tree;
  await Promise.all([
    page.screenshotBase64().then((base64) => {
      screenshotBase64 = base64;
    }),
    page.getElementsNodeTree().then(async (treeRoot) => {
      tree = treeRoot;
    })
  ]);
  const webTree = (0, import_extractor.traverseTree)(tree, (elementInfo) => {
    const { rect, id, content, attributes, locator, indexId } = elementInfo;
    return new WebElementInfo({
      rect,
      locator,
      id,
      content,
      attributes,
      indexId
    });
  });
  const elementsInfo = (0, import_extractor.treeToList)(webTree);
  (0, import_utils2.assert)(screenshotBase64, "screenshotBase64 is required");
  const elementsPositionInfoWithoutText = elementsInfo.filter(
    (elementInfo) => {
      if (elementInfo.attributes.nodeType === import_constants.NodeType.TEXT) {
        return false;
      }
      return true;
    }
  );
  const size = await page.size();
  if (size.dpr && size.dpr > 1) {
    screenshotBase64 = await (0, import_img.resizeImgBase64)(screenshotBase64, {
      width: size.width,
      height: size.height
    });
  }
  let screenshotBase64WithElementMarker = screenshotBase64;
  if (!(0, import_env.getAIConfig)(import_env.MIDSCENE_USE_VLM_UI_TARS)) {
    if (_opt?.ignoreMarker) {
      screenshotBase64WithElementMarker = screenshotBase64;
    } else {
      screenshotBase64WithElementMarker = await (0, import_img.compositeElementInfoImg)({
        inputImgBase64: screenshotBase64,
        elementsPositionInfo: elementsPositionInfoWithoutText,
        size
      });
    }
  }
  return {
    content: elementsInfo,
    tree: webTree,
    size,
    screenshotBase64,
    screenshotBase64WithElementMarker,
    url
  };
}
function reportFileName(tag = "web") {
  const reportTagName = (0, import_env.getAIConfig)(import_env.MIDSCENE_REPORT_TAG_NAME);
  const dateTimeInFileName = (0, import_dayjs.default)().format("YYYY-MM-DD_HH-mm-ss-SSS");
  return `${reportTagName || tag}-${dateTimeInFileName}`;
}
function printReportMsg(filepath) {
  console.log("Midscene - report file updated:", filepath);
}
var ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED = "NOT_IMPLEMENTED_AS_DESIGNED";

// src/common/agent.ts
var import_core2 = require("@midscene/core");
var import_constants2 = require("@midscene/shared/constants");

// src/yaml/player.ts
var import_node_fs = require("fs");
var import_node_path = require("path");
var import_utils3 = require("@midscene/shared/utils");
var ScriptPlayer = class {
  constructor(script, setupAgent, onTaskStatusChange) {
    this.script = script;
    this.setupAgent = setupAgent;
    this.onTaskStatusChange = onTaskStatusChange;
    this.taskStatusList = [];
    this.status = "init";
    this.unnamedResultIndex = 0;
    this.pageAgent = null;
    this.result = {};
    this.output = script.target?.output;
    this.taskStatusList = (script.tasks || []).map((task, taskIndex) => ({
      ...task,
      index: taskIndex,
      status: "init",
      totalSteps: task.flow?.length || 0
    }));
  }
  setPlayerStatus(status, error) {
    this.status = status;
    this.errorInSetup = error;
  }
  notifyCurrentTaskStatusChange(taskIndex) {
    const taskIndexToNotify = typeof taskIndex === "number" ? taskIndex : this.currentTaskIndex;
    if (typeof taskIndexToNotify !== "number") {
      return;
    }
    const taskStatus = this.taskStatusList[taskIndexToNotify];
    if (this.onTaskStatusChange) {
      this.onTaskStatusChange(taskStatus);
    }
  }
  async setTaskStatus(index, statusValue, error) {
    this.taskStatusList[index].status = statusValue;
    if (error) {
      this.taskStatusList[index].error = error;
    }
    this.notifyCurrentTaskStatusChange(index);
  }
  setTaskIndex(taskIndex) {
    this.currentTaskIndex = taskIndex;
  }
  flushResult() {
    if (Object.keys(this.result).length && this.output) {
      const output = (0, import_node_path.join)(process.cwd(), this.output);
      const outputDir = (0, import_node_path.dirname)(output);
      if (!(0, import_node_fs.existsSync)(outputDir)) {
        (0, import_node_fs.mkdirSync)(outputDir, { recursive: true });
      }
      (0, import_node_fs.writeFileSync)(output, JSON.stringify(this.result, void 0, 2));
    }
  }
  async playTask(taskStatus, agent) {
    const { flow } = taskStatus;
    (0, import_utils3.assert)(flow, "missing flow in task");
    for (const flowItemIndex in flow) {
      const currentStep = Number.parseInt(flowItemIndex, 10);
      taskStatus.currentStep = currentStep;
      const flowItem = flow[flowItemIndex];
      if (flowItem.aiAction || flowItem.ai) {
        const actionTask = flowItem;
        const prompt = actionTask.aiAction || actionTask.ai;
        (0, import_utils3.assert)(prompt, "missing prompt for ai (aiAction)");
        (0, import_utils3.assert)(
          typeof prompt === "string",
          "prompt for aiAction must be a string"
        );
        await agent.aiAction(prompt);
      } else if (flowItem.aiAssert) {
        const assertTask = flowItem;
        const prompt = assertTask.aiAssert;
        (0, import_utils3.assert)(prompt, "missing prompt for aiAssert");
        (0, import_utils3.assert)(
          typeof prompt === "string",
          "prompt for aiAssert must be a string"
        );
        await agent.aiAssert(prompt);
      } else if (flowItem.aiQuery) {
        const queryTask = flowItem;
        const prompt = queryTask.aiQuery;
        (0, import_utils3.assert)(prompt, "missing prompt for aiQuery");
        (0, import_utils3.assert)(
          typeof prompt === "string",
          "prompt for aiQuery must be a string"
        );
        const queryResult = await agent.aiQuery(prompt);
        const resultKey = queryTask.name || this.unnamedResultIndex++;
        if (this.result[resultKey]) {
          console.warn(
            `result key ${resultKey} already exists, will overwrite`
          );
        }
        this.result[resultKey] = queryResult;
        this.flushResult();
      } else if (flowItem.aiWaitFor) {
        const waitForTask = flowItem;
        const prompt = waitForTask.aiWaitFor;
        (0, import_utils3.assert)(prompt, "missing prompt for aiWaitFor");
        (0, import_utils3.assert)(
          typeof prompt === "string",
          "prompt for aiWaitFor must be a string"
        );
        const timeout = waitForTask.timeout;
        await agent.aiWaitFor(prompt, { timeoutMs: timeout });
      } else if (flowItem.sleep) {
        const sleepTask = flowItem;
        const ms = sleepTask.sleep;
        let msNumber = ms;
        if (typeof ms === "string") {
          msNumber = Number.parseInt(ms, 10);
        }
        (0, import_utils3.assert)(
          msNumber && msNumber > 0,
          `ms for sleep must be greater than 0, but got ${ms}`
        );
        await new Promise((resolve) => setTimeout(resolve, msNumber));
      } else {
        throw new Error(`unknown flowItem: ${JSON.stringify(flowItem)}`);
      }
    }
    this.reportFile = agent.reportFile;
  }
  async run() {
    const { target, tasks } = this.script;
    this.setPlayerStatus("running");
    let agent = null;
    let freeFn = [];
    try {
      const { agent: newAgent, freeFn: newFreeFn } = await this.setupAgent(target);
      agent = newAgent;
      freeFn = newFreeFn;
    } catch (e) {
      this.setPlayerStatus("error", e);
      return;
    }
    this.pageAgent = agent;
    let taskIndex = 0;
    this.setPlayerStatus("running");
    let errorFlag = false;
    while (taskIndex < tasks.length) {
      const taskStatus = this.taskStatusList[taskIndex];
      this.setTaskStatus(taskIndex, "running");
      this.setTaskIndex(taskIndex);
      try {
        await this.playTask(taskStatus, this.pageAgent);
        this.setTaskStatus(taskIndex, "done");
      } catch (e) {
        this.setTaskStatus(taskIndex, "error", e);
        if (taskStatus.continueOnError) {
        } else {
          this.reportFile = agent.reportFile;
          errorFlag = true;
          break;
        }
      }
      this.reportFile = agent.reportFile;
      taskIndex++;
    }
    if (errorFlag) {
      this.setPlayerStatus("error");
    } else {
      this.setPlayerStatus("done");
    }
    for (const fn of freeFn) {
      try {
        await fn.fn();
      } catch (e) {
      }
    }
  }
};

// src/yaml/builder.ts
var import_js_yaml = __toESM(require("js-yaml"));

// src/yaml/utils.ts
var import_utils4 = require("@midscene/shared/utils");
var import_js_yaml2 = __toESM(require("js-yaml"));
function interpolateEnvVars(content) {
  return content.replace(/\$\{([^}]+)\}/g, (_, envVar) => {
    const value = process.env[envVar.trim()];
    if (value === void 0) {
      throw new Error(`Environment variable "${envVar.trim()}" is not defined`);
    }
    return value;
  });
}
function parseYamlScript(content, filePath, ignoreCheckingTarget) {
  const interpolatedContent = interpolateEnvVars(content);
  const obj = import_js_yaml2.default.load(interpolatedContent);
  const pathTip = filePath ? `, failed to load ${filePath}` : "";
  if (!ignoreCheckingTarget) {
    (0, import_utils4.assert)(
      obj.target,
      `property "target" is required in yaml script${pathTip}`
    );
    (0, import_utils4.assert)(
      typeof obj.target === "object",
      `property "target" must be an object${pathTip}`
    );
  }
  (0, import_utils4.assert)(obj.tasks, `property "tasks" is required in yaml script ${pathTip}`);
  (0, import_utils4.assert)(
    Array.isArray(obj.tasks),
    `property "tasks" must be an array in yaml script, but got ${obj.tasks}`
  );
  return obj;
}

// src/common/agent.ts
var import_env3 = require("@midscene/core/env");
var import_utils10 = require("@midscene/core/utils");

// src/common/tasks.ts
var import_core = require("@midscene/core");
var import_ai_model = require("@midscene/core/ai-model");
var import_utils7 = require("@midscene/core/utils");
var import_utils8 = require("@midscene/shared/utils");

// src/common/task-cache.ts
var import_node_fs2 = require("fs");
var import_node_path2 = require("path");
var import_env2 = require("@midscene/core/env");
var import_utils5 = require("@midscene/core/utils");
var import_fs = require("@midscene/shared/fs");
var import_utils6 = require("@midscene/shared/utils");
var debug = (0, import_utils6.getDebug)("cache");
var TaskCache = class {
  constructor(opts) {
    this.midscenePkgInfo = (0, import_fs.getRunningPkgInfo)();
    this.cacheId = opts?.cacheId || "";
    this.cache = this.readCacheFromFile() || {
      aiTasks: []
    };
    this.newCache = {
      aiTasks: []
    };
  }
  getCacheGroupByPrompt(aiActionPrompt) {
    const { aiTasks = [] } = this.cache || { aiTasks: [] };
    const index = aiTasks.findIndex((item) => item.prompt === aiActionPrompt);
    const newCacheGroup = [];
    this.newCache.aiTasks.push({
      prompt: aiActionPrompt,
      tasks: newCacheGroup
    });
    return {
      matchCache: (pageContext, type, actionPrompt) => {
        if (index === -1) {
          return false;
        }
        if (type === "plan") {
          return this.matchCache(
            pageContext,
            type,
            actionPrompt,
            aiTasks[index].tasks
          );
        }
        if (type === "ui-tars-plan") {
          return this.matchCache(
            pageContext,
            type,
            actionPrompt,
            aiTasks[index].tasks
          );
        }
        return this.matchCache(
          pageContext,
          type,
          actionPrompt,
          aiTasks[index].tasks
        );
      },
      saveCache: (cache) => {
        newCacheGroup.push(cache);
        debug(
          "saving cache to file, type: %s, cacheId: %s",
          cache.type,
          this.cacheId
        );
        this.writeCacheToFile();
      }
    };
  }
  matchCache(pageContext, type, userPrompt, cacheGroup) {
    debug(
      "will read cache, type: %s, prompt: %s, cacheGroupLength: %s",
      type,
      userPrompt,
      cacheGroup.length
    );
    if (cacheGroup.length > 0) {
      const index = cacheGroup.findIndex((item) => item.prompt === userPrompt);
      if (index === -1) {
        debug("cannot find any cache matching prompt: %s", userPrompt);
        return false;
      }
      const taskRes = cacheGroup.splice(index, 1)[0];
      debug(
        "found cache with same prompt, type: %s, prompt: %s, cached response is %j",
        type,
        userPrompt,
        taskRes?.response
      );
      if (taskRes?.type === "locate") {
        const id = taskRes.response?.elements[0].id;
        if (!id) {
          debug("no id in cached response");
          return false;
        }
        const foundInContext = pageContext.content.find(
          (contentElement) => contentElement.id === id
        );
        if (!foundInContext) {
          debug("cannot match element with same id in current page");
          return false;
        }
        return taskRes.response;
      }
      if (taskRes && taskRes.type === type && taskRes.prompt === userPrompt) {
        const contextEqual = this.pageContextEqual(
          taskRes.pageContext,
          pageContext
        );
        if (!contextEqual) {
          debug(
            "cache almost hit, type: %s, prompt: %s, but context not equal, will not use cache",
            type,
            userPrompt
          );
          return false;
        }
        debug("cache hit, type: %s, prompt: %s", type, userPrompt);
        return taskRes.response;
      }
    }
    debug("no cache hit, type: %s, prompt: %s", type, userPrompt);
    return false;
  }
  pageContextEqual(taskPageContext, pageContext) {
    debug(
      "comparing page context size: %s x %s, %s x %s",
      taskPageContext.size.width,
      taskPageContext.size.height,
      pageContext.size.width,
      pageContext.size.height
    );
    return taskPageContext.size.width === pageContext.size.width && taskPageContext.size.height === pageContext.size.height;
  }
  /**
   * Generate task cache data.
   * This method is mainly used to create or obtain some cached data for tasks, and it returns a new cache object.
   * In the cache object, it may contain task-related information, states, or other necessary data.
   * It is assumed that the `newCache` property already exists in the current class or object and is a data structure used to store task cache.
   * @returns {Object} Returns a new cache object, which may include task cache data.
   */
  generateTaskCache() {
    return this.newCache;
  }
  readCacheFromFile() {
    if (import_utils6.ifInBrowser || !this.cacheId) {
      return void 0;
    }
    const cacheFile = (0, import_node_path2.join)((0, import_utils5.getLogDirByType)("cache"), `${this.cacheId}.json`);
    if (!(0, import_env2.getAIConfigInBoolean)("MIDSCENE_CACHE")) {
      return void 0;
    }
    if ((0, import_node_fs2.existsSync)(cacheFile)) {
      try {
        const data = (0, import_node_fs2.readFileSync)(cacheFile, "utf8");
        const jsonData = JSON.parse(data);
        if (!this.midscenePkgInfo) {
          return void 0;
        }
        const jsonDataPkgVersion = jsonData.pkgVersion.split(".");
        const midscenePkgInfoPkgVersion = this.midscenePkgInfo.version.split(".");
        if (jsonDataPkgVersion[0] !== midscenePkgInfoPkgVersion[0] || jsonDataPkgVersion[1] !== midscenePkgInfoPkgVersion[1]) {
          return void 0;
        }
        debug("read cache from file: %s", cacheFile);
        return jsonData;
      } catch (err) {
        debug(
          "cache file exists but parse failed, path: %s, error: %s",
          cacheFile,
          err
        );
        return void 0;
      }
    }
    debug("no cache file found, path: %s", cacheFile);
    return void 0;
  }
  writeCacheToFile() {
    const midscenePkgInfo = (0, import_fs.getRunningPkgInfo)();
    if (!midscenePkgInfo) {
      debug("no midscene pkg info, will not write cache to file");
      return;
    }
    if (!this.cacheId) {
      debug("no cache id, will not write cache to file");
      return;
    }
    if (!import_utils6.ifInBrowser) {
      (0, import_utils5.writeLogFile)({
        fileName: `${this.cacheId}`,
        fileExt: "json",
        fileContent: (0, import_utils5.stringifyDumpData)(
          {
            pkgName: midscenePkgInfo.name,
            pkgVersion: midscenePkgInfo.version,
            cacheId: this.cacheId,
            ...this.newCache
          },
          2
        ),
        type: "cache"
      });
    }
  }
};

// src/common/ui-utils.ts
function typeStr(task) {
  return task.subType ? `${task.type} / ${task.subType || ""}` : task.type;
}
function getKeyCommands(value) {
  const keys = Array.isArray(value) ? value : [value];
  return keys.reduce((acc, k) => {
    const includeMeta = keys.includes("Meta") || keys.includes("Control");
    if (includeMeta && (k === "a" || k === "A")) {
      return acc.concat([{ key: k, command: "SelectAll" }]);
    }
    if (includeMeta && (k === "c" || k === "C")) {
      return acc.concat([{ key: k, command: "Copy" }]);
    }
    if (includeMeta && (k === "v" || k === "V")) {
      return acc.concat([{ key: k, command: "Paste" }]);
    }
    return acc.concat([{ key: k }]);
  }, []);
}
function paramStr(task) {
  let value;
  if (task.type === "Planning") {
    value = task?.param?.userInstruction;
  }
  if (task.type === "Insight") {
    value = task?.param?.prompt || task?.param?.id || task?.param?.dataDemand || task?.param?.assertion;
  }
  if (task.type === "Action") {
    const sleepMs = task?.param?.timeMs;
    const scrollType = task?.param?.scrollType;
    if (sleepMs) {
      value = `${sleepMs}ms`;
    } else if (scrollType) {
      const scrollDirection = task?.param?.direction;
      const scrollDistance = task?.param?.distance;
      value = `${scrollDirection || "down"}, ${scrollType || "once"}, ${scrollDistance || "distance-not-set"}`;
    } else {
      value = task?.param?.value || task?.param?.scrollType;
    }
    if (!value) {
      value = task.thought;
    }
  }
  if (typeof value === "undefined")
    return "";
  return typeof value === "string" ? value : JSON.stringify(value, void 0, 2);
}
var limitOpenNewTabScript = `
if (!window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__) {
  window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__ = true;

  // Intercept the window.open method (only once)
  window.open = function(url) {
    console.log('Blocked window.open:', url);
    window.location.href = url;
    return null;
  };

  // Block all a tag clicks with target="_blank" (only once)
  document.addEventListener('click', function(e) {
    const target = e.target.closest('a');
    if (target && target.target === '_blank') {
      e.preventDefault();
      console.log('Blocked new tab:', target.href);
      window.location.href = target.href;
      target.removeAttribute('target');
    }
  }, true);
}
`;

// src/common/tasks.ts
var replanningCountLimit = 10;
var PageTaskExecutor = class {
  constructor(page, insight, opts) {
    this.conversationHistory = [];
    this.page = page;
    this.insight = insight;
    this.taskCache = new TaskCache({
      cacheId: opts?.cacheId
    });
  }
  async recordScreenshot(timing) {
    const base64 = await this.page.screenshotBase64();
    const item = {
      type: "screenshot",
      ts: Date.now(),
      screenshot: base64,
      timing
    };
    return item;
  }
  prependExecutorWithScreenshot(taskApply, appendAfterExecution = false) {
    const taskWithScreenshot = {
      ...taskApply,
      executor: async (param, context, ...args) => {
        const recorder = [];
        const { task } = context;
        task.recorder = recorder;
        const shot = await this.recordScreenshot(`before ${task.type}`);
        recorder.push(shot);
        const result = await taskApply.executor(param, context, ...args);
        if (taskApply.type === "Action") {
          await Promise.all([
            (async () => {
              await (0, import_utils7.sleep)(100);
              if (this.page.waitUntilNetworkIdle) {
                try {
                  await this.page.waitUntilNetworkIdle({
                    idleTime: 100,
                    timeout: 800
                  });
                } catch (error) {
                }
              }
            })(),
            (0, import_utils7.sleep)(200)
          ]);
        }
        if (appendAfterExecution) {
          const shot2 = await this.recordScreenshot("after Action");
          recorder.push(shot2);
        }
        return result;
      }
    };
    return taskWithScreenshot;
  }
  async convertPlanToExecutable(plans, cacheGroup) {
    const tasks = [];
    plans.forEach((plan2) => {
      if (plan2.type === "Locate") {
        if (plan2.locate === null || plan2.locate?.id === null || plan2.locate?.id === "null") {
          return;
        }
        const taskFind = {
          type: "Insight",
          subType: "Locate",
          param: plan2.locate || void 0,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, taskContext) => {
            const { task } = taskContext;
            (0, import_utils8.assert)(
              param?.prompt || param?.id || param?.bbox,
              "No prompt or id or position or bbox to locate"
            );
            let insightDump;
            let usage;
            const dumpCollector = (dump) => {
              insightDump = dump;
              usage = dump?.taskInfo?.usage;
            };
            this.insight.onceDumpUpdatedFn = dumpCollector;
            const shotTime = Date.now();
            const pageContext = await this.insight.contextRetrieverFn("locate");
            const recordItem = {
              type: "screenshot",
              ts: shotTime,
              screenshot: pageContext.screenshotBase64,
              timing: "before locate"
            };
            const cachePrompt = `${param.prompt} @ ${param.searchArea || ""}`;
            const locateCache = cacheGroup?.matchCache(
              pageContext,
              "locate",
              cachePrompt
            );
            const idInCache = locateCache?.elements?.[0]?.id;
            let cacheHitFlag = false;
            let quickAnswerId = param?.id;
            if (!quickAnswerId && idInCache) {
              quickAnswerId = idInCache;
            }
            const quickAnswer = {
              id: quickAnswerId,
              bbox: param?.bbox
            };
            const startTime = Date.now();
            const element = await this.insight.locate(param, {
              quickAnswer
            });
            const aiCost = Date.now() - startTime;
            if (element && element.id === quickAnswerId) {
              cacheHitFlag = true;
            }
            if (element) {
              cacheGroup?.saveCache({
                type: "locate",
                pageContext: {
                  url: pageContext.url,
                  size: pageContext.size
                },
                prompt: cachePrompt,
                response: {
                  elements: [
                    {
                      id: element.id
                    }
                  ]
                }
              });
            }
            if (!element) {
              task.log = {
                dump: insightDump
              };
              throw new Error(`Element not found: ${param.prompt}`);
            }
            return {
              output: {
                element
              },
              pageContext,
              log: {
                dump: insightDump
              },
              cache: {
                hit: cacheHitFlag
              },
              recorder: [recordItem],
              aiCost,
              usage
            };
          }
        };
        tasks.push(taskFind);
      } else if (plan2.type === "Assert" || plan2.type === "AssertWithoutThrow") {
        const assertPlan = plan2;
        const taskAssert = {
          type: "Insight",
          subType: "Assert",
          param: assertPlan.param,
          thought: assertPlan.thought,
          locate: assertPlan.locate,
          executor: async (param, taskContext) => {
            const { task } = taskContext;
            let insightDump;
            const dumpCollector = (dump) => {
              insightDump = dump;
            };
            this.insight.onceDumpUpdatedFn = dumpCollector;
            const assertion = await this.insight.assert(
              assertPlan.param.assertion
            );
            if (!assertion.pass) {
              if (plan2.type === "Assert") {
                task.output = assertion;
                task.log = {
                  dump: insightDump
                };
                throw new Error(
                  assertion.thought || "Assertion failed without reason"
                );
              }
              task.error = assertion.thought;
            }
            return {
              output: assertion,
              log: {
                dump: insightDump
              },
              usage: assertion.usage
            };
          }
        };
        tasks.push(taskAssert);
      } else if (plan2.type === "Input") {
        const taskActionInput = {
          type: "Action",
          subType: "Input",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam, { element }) => {
            if (element) {
              await this.page.clearInput(element);
              if (!taskParam || !taskParam.value) {
                return;
              }
              await this.page.keyboard.type(taskParam.value);
            } else {
              await this.page.keyboard.type(taskParam.value);
            }
          }
        };
        tasks.push(taskActionInput);
      } else if (plan2.type === "KeyboardPress") {
        const taskActionKeyboardPress = {
          type: "Action",
          subType: "KeyboardPress",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            const keys = getKeyCommands(taskParam.value);
            await this.page.keyboard.press(keys);
          }
        };
        tasks.push(taskActionKeyboardPress);
      } else if (plan2.type === "Tap") {
        const taskActionTap = {
          type: "Action",
          subType: "Tap",
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, { element }) => {
            (0, import_utils8.assert)(element, "Element not found, cannot tap");
            await this.page.mouse.click(element.center[0], element.center[1]);
          }
        };
        tasks.push(taskActionTap);
      } else if (plan2.type === "Drag") {
        const taskActionDrag = {
          type: "Action",
          subType: "Drag",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            (0, import_utils8.assert)(
              taskParam?.start_box && taskParam?.end_box,
              "No start_box or end_box to drag"
            );
            await this.page.mouse.drag(taskParam.start_box, taskParam.end_box);
          }
        };
        tasks.push(taskActionDrag);
      } else if (plan2.type === "Hover") {
        const taskActionHover = {
          type: "Action",
          subType: "Hover",
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, { element }) => {
            (0, import_utils8.assert)(element, "Element not found, cannot hover");
            await this.page.mouse.move(element.center[0], element.center[1]);
          }
        };
        tasks.push(taskActionHover);
      } else if (plan2.type === "Scroll") {
        const taskActionScroll = {
          type: "Action",
          subType: "Scroll",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam, { element }) => {
            const startingPoint = element ? {
              left: element.center[0],
              top: element.center[1]
            } : void 0;
            const scrollToEventName = taskParam?.scrollType;
            if (scrollToEventName === "untilTop") {
              await this.page.scrollUntilTop(startingPoint);
            } else if (scrollToEventName === "untilBottom") {
              await this.page.scrollUntilBottom(startingPoint);
            } else if (scrollToEventName === "untilRight") {
              await this.page.scrollUntilRight(startingPoint);
            } else if (scrollToEventName === "untilLeft") {
              await this.page.scrollUntilLeft(startingPoint);
            } else if (scrollToEventName === "once" || !scrollToEventName) {
              if (taskParam?.direction === "down" || !taskParam || !taskParam.direction) {
                await this.page.scrollDown(
                  taskParam?.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "up") {
                await this.page.scrollUp(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "left") {
                await this.page.scrollLeft(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "right") {
                await this.page.scrollRight(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else {
                throw new Error(
                  `Unknown scroll direction: ${taskParam.direction}`
                );
              }
              await (0, import_utils7.sleep)(500);
            } else {
              throw new Error(
                `Unknown scroll event type: ${scrollToEventName}, taskParam: ${JSON.stringify(
                  taskParam
                )}`
              );
            }
          }
        };
        tasks.push(taskActionScroll);
      } else if (plan2.type === "Sleep") {
        const taskActionSleep = {
          type: "Action",
          subType: "Sleep",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            await (0, import_utils7.sleep)(taskParam?.timeMs || 3e3);
          }
        };
        tasks.push(taskActionSleep);
      } else if (plan2.type === "Error") {
        const taskActionError = {
          type: "Action",
          subType: "Error",
          param: plan2.param,
          thought: plan2.thought || plan2.param?.thought,
          locate: plan2.locate,
          executor: async () => {
            throw new Error(
              plan2?.thought || plan2.param?.thought || "error without thought"
            );
          }
        };
        tasks.push(taskActionError);
      } else if (plan2.type === "ExpectedFalsyCondition") {
        const taskActionFalsyConditionStatement = {
          type: "Action",
          subType: "ExpectedFalsyCondition",
          param: null,
          thought: plan2.param?.reason,
          locate: plan2.locate,
          executor: async () => {
          }
        };
        tasks.push(taskActionFalsyConditionStatement);
      } else if (plan2.type === "Finished") {
        const taskActionFinished = {
          type: "Action",
          subType: "Finished",
          param: null,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param) => {
          }
        };
        tasks.push(taskActionFinished);
      } else {
        throw new Error(`Unknown or unsupported task type: ${plan2.type}`);
      }
    });
    const wrappedTasks = tasks.map(
      (task, index) => {
        if (task.type === "Action") {
          return this.prependExecutorWithScreenshot(
            task,
            index === tasks.length - 1
          );
        }
        return task;
      }
    );
    return {
      tasks: wrappedTasks
    };
  }
  planningTaskFromPrompt(userInstruction, cacheGroup, log) {
    const task = {
      type: "Planning",
      locate: null,
      param: {
        userInstruction,
        log
      },
      executor: async (param, executorContext) => {
        const shotTime = Date.now();
        const pageContext = await this.insight.contextRetrieverFn("locate");
        const recordItem = {
          type: "screenshot",
          ts: shotTime,
          screenshot: pageContext.screenshotBase64,
          timing: "before planning"
        };
        executorContext.task.recorder = [recordItem];
        executorContext.task.pageContext = pageContext;
        const cachePrompt = `${param.userInstruction} @ ${param.log || ""}`;
        const planCache = cacheGroup.matchCache(
          pageContext,
          "plan",
          cachePrompt
        );
        let planResult;
        if (planCache) {
          if ("actions" in planCache && Array.isArray(planCache.actions)) {
            planCache.actions = planCache.actions.map((action) => {
              if (action.locate) {
                delete action.locate.bbox;
              }
              return action;
            });
          }
          planResult = planCache;
        } else {
          planResult = await (0, import_core.plan)(param.userInstruction, {
            context: pageContext,
            log: param.log
          });
        }
        const {
          actions,
          log: log2,
          more_actions_needed_by_instruction,
          error,
          usage,
          rawResponse,
          sleep: sleep3
        } = planResult;
        let stopCollecting = false;
        let bboxCollected = false;
        let planParsingError = "";
        const finalActions = (actions || []).reduce(
          (acc, planningAction) => {
            if (stopCollecting) {
              return acc;
            }
            if (planningAction.locate) {
              if (bboxCollected && planningAction.locate.bbox) {
                delete planningAction.locate.bbox;
              }
              if (planningAction.locate.bbox) {
                bboxCollected = true;
              }
              acc.push({
                type: "Locate",
                locate: planningAction.locate,
                param: null,
                thought: planningAction.locate.prompt
              });
            } else if (["Tap", "Hover", "Input"].includes(planningAction.type)) {
              planParsingError = `invalid planning response: ${JSON.stringify(planningAction)}`;
              stopCollecting = true;
              return acc;
            }
            acc.push(planningAction);
            return acc;
          },
          []
        );
        if (sleep3) {
          const timeNow = Date.now();
          const timeRemaining = sleep3 - (timeNow - shotTime);
          if (timeRemaining > 0) {
            finalActions.push({
              type: "Sleep",
              param: {
                timeMs: timeRemaining
              },
              locate: null
            });
          }
        }
        if (finalActions.length === 0) {
          (0, import_utils8.assert)(
            !more_actions_needed_by_instruction || sleep3,
            error ? `Failed to plan: ${error}` : planParsingError || "No plan found"
          );
        }
        cacheGroup.saveCache({
          type: "plan",
          pageContext: {
            url: pageContext.url,
            size: pageContext.size
          },
          prompt: cachePrompt,
          response: planResult
        });
        return {
          output: {
            actions: finalActions,
            more_actions_needed_by_instruction,
            log: log2
          },
          cache: {
            hit: Boolean(planCache)
          },
          pageContext,
          recorder: [recordItem],
          usage,
          rawResponse
        };
      }
    };
    return task;
  }
  planningTaskToGoal(userInstruction, cacheGroup) {
    const task = {
      type: "Planning",
      locate: null,
      param: {
        userInstruction
      },
      executor: async (param, executorContext) => {
        const shotTime = Date.now();
        const pageContext = await this.insight.contextRetrieverFn("locate");
        const recordItem = {
          type: "screenshot",
          ts: shotTime,
          screenshot: pageContext.screenshotBase64,
          timing: "before planning"
        };
        executorContext.task.recorder = [recordItem];
        executorContext.task.pageContext = pageContext;
        this.appendConversationHistory({
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: {
                url: pageContext.screenshotBase64
              }
            }
          ]
        });
        const startTime = Date.now();
        const planCache = cacheGroup.matchCache(
          pageContext,
          "ui-tars-plan",
          userInstruction
        );
        let planResult;
        if (planCache) {
          planResult = planCache;
        } else {
          planResult = await (0, import_ai_model.vlmPlanning)({
            userInstruction: param.userInstruction,
            conversationHistory: this.conversationHistory,
            size: pageContext.size
          });
        }
        cacheGroup.saveCache({
          type: "ui-tars-plan",
          pageContext: {
            url: pageContext.url,
            size: pageContext.size
          },
          prompt: userInstruction,
          response: planResult
        });
        const aiCost = Date.now() - startTime;
        const { actions, action_summary } = planResult;
        this.appendConversationHistory({
          role: "assistant",
          content: action_summary
        });
        return {
          output: {
            actions,
            thought: actions[0]?.thought,
            actionType: actions[0].type,
            more_actions_needed_by_instruction: true,
            log: ""
          },
          cache: {
            hit: Boolean(planCache)
          },
          aiCost
        };
      }
    };
    return task;
  }
  async runPlans(title, plans, options) {
    const taskExecutor = new import_core.Executor(title, {
      onTaskStart: options?.onTaskStart
    });
    const { tasks } = await this.convertPlanToExecutable(plans);
    await taskExecutor.append(tasks);
    const result = await taskExecutor.flush();
    return {
      output: result,
      executor: taskExecutor
    };
  }
  async action(userPrompt, options) {
    const taskExecutor = new import_core.Executor(userPrompt, {
      onTaskStart: options?.onTaskStart
    });
    const cacheGroup = this.taskCache.getCacheGroupByPrompt(userPrompt);
    let planningTask = this.planningTaskFromPrompt(userPrompt, cacheGroup);
    let result;
    let replanCount = 0;
    const logLog = [];
    while (planningTask) {
      if (replanCount > replanningCountLimit) {
        const errorMsg = "Replanning too many times, please split the task into multiple steps";
        return this.appendErrorPlan(taskExecutor, errorMsg);
      }
      await taskExecutor.append(planningTask);
      const planResult = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: planResult,
          executor: taskExecutor
        };
      }
      const plans = planResult.actions || [];
      let executables;
      try {
        executables = await this.convertPlanToExecutable(plans, cacheGroup);
        taskExecutor.append(executables.tasks);
      } catch (error) {
        return this.appendErrorPlan(
          taskExecutor,
          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(
            plans
          )}`
        );
      }
      result = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: result,
          executor: taskExecutor
        };
      }
      if (planResult?.log) {
        logLog.push(planResult.log);
      }
      if (!planResult.more_actions_needed_by_instruction) {
        planningTask = null;
        break;
      }
      planningTask = this.planningTaskFromPrompt(
        userPrompt,
        cacheGroup,
        logLog.join("\n")
      );
      replanCount++;
    }
    return {
      output: result,
      executor: taskExecutor
    };
  }
  async actionToGoal(userPrompt, options) {
    const taskExecutor = new import_core.Executor(userPrompt, {
      onTaskStart: options?.onTaskStart
    });
    this.conversationHistory = [];
    const cacheGroup = this.taskCache.getCacheGroupByPrompt(userPrompt);
    const isCompleted = false;
    let currentActionNumber = 0;
    const maxActionNumber = 40;
    while (!isCompleted && currentActionNumber < maxActionNumber) {
      currentActionNumber++;
      const planningTask = this.planningTaskToGoal(
        userPrompt,
        cacheGroup
      );
      await taskExecutor.append(planningTask);
      const output = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output,
          executor: taskExecutor
        };
      }
      const plans = output.actions;
      let executables;
      try {
        executables = await this.convertPlanToExecutable(plans);
        taskExecutor.append(executables.tasks);
      } catch (error) {
        return this.appendErrorPlan(
          taskExecutor,
          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(
            plans
          )}`
        );
      }
      const result = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: result,
          executor: taskExecutor
        };
      }
      if (plans[0].type === "Finished") {
        break;
      }
    }
    return {
      output: {},
      executor: taskExecutor
    };
  }
  async query(demand, options) {
    const description = typeof demand === "string" ? demand : JSON.stringify(demand);
    const taskExecutor = new import_core.Executor(description, {
      onTaskStart: options?.onTaskStart
    });
    const queryTask = {
      type: "Insight",
      subType: "Query",
      locate: null,
      param: {
        dataDemand: demand
      },
      executor: async (param) => {
        let insightDump;
        const dumpCollector = (dump) => {
          insightDump = dump;
        };
        this.insight.onceDumpUpdatedFn = dumpCollector;
        const { data, usage } = await this.insight.extract(
          param.dataDemand
        );
        return {
          output: data,
          log: { dump: insightDump },
          usage
        };
      }
    };
    await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));
    const output = await taskExecutor.flush();
    return {
      output,
      executor: taskExecutor
    };
  }
  async assert(assertion, options) {
    const description = `assert: ${assertion}`;
    const taskExecutor = new import_core.Executor(description, {
      onTaskStart: options?.onTaskStart
    });
    const assertionPlan = {
      type: "Assert",
      param: {
        assertion
      },
      locate: null
    };
    const { tasks } = await this.convertPlanToExecutable([assertionPlan]);
    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));
    const output = await taskExecutor.flush();
    return {
      output,
      executor: taskExecutor
    };
  }
  /**
   * Append a message to the conversation history
   * For user messages with images:
   * - Keep max 4 user image messages in history
   * - Remove oldest user image message when limit reached
   * For assistant messages:
   * - Simply append to history
   * @param conversationHistory Message to append
   */
  appendConversationHistory(conversationHistory) {
    if (conversationHistory.role === "user") {
      const userImgItems = this.conversationHistory.filter(
        (item) => item.role === "user"
      );
      if (userImgItems.length >= 4 && conversationHistory.role === "user") {
        const firstUserImgIndex = this.conversationHistory.findIndex(
          (item) => item.role === "user"
        );
        if (firstUserImgIndex >= 0) {
          this.conversationHistory.splice(firstUserImgIndex, 1);
        }
      }
    }
    this.conversationHistory.push(conversationHistory);
  }
  async appendErrorPlan(taskExecutor, errorMsg) {
    const errorPlan = {
      type: "Error",
      param: {
        thought: errorMsg
      },
      locate: null
    };
    const { tasks } = await this.convertPlanToExecutable([errorPlan]);
    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));
    await taskExecutor.flush();
    return {
      output: void 0,
      executor: taskExecutor
    };
  }
  async waitFor(assertion, opt) {
    const description = `waitFor: ${assertion}`;
    const taskExecutor = new import_core.Executor(description, {
      onTaskStart: opt.onTaskStart
    });
    const { timeoutMs, checkIntervalMs } = opt;
    (0, import_utils8.assert)(assertion, "No assertion for waitFor");
    (0, import_utils8.assert)(timeoutMs, "No timeoutMs for waitFor");
    (0, import_utils8.assert)(checkIntervalMs, "No checkIntervalMs for waitFor");
    const overallStartTime = Date.now();
    let startTime = Date.now();
    let errorThought = "";
    while (Date.now() - overallStartTime < timeoutMs) {
      startTime = Date.now();
      const assertPlan = {
        type: "AssertWithoutThrow",
        param: {
          assertion
        },
        locate: null
      };
      const { tasks: assertTasks } = await this.convertPlanToExecutable([
        assertPlan
      ]);
      await taskExecutor.append(
        this.prependExecutorWithScreenshot(assertTasks[0])
      );
      const output = await taskExecutor.flush();
      if (output?.pass) {
        return {
          output: void 0,
          executor: taskExecutor
        };
      }
      errorThought = output?.thought || `unknown error when waiting for assertion: ${assertion}`;
      const now = Date.now();
      if (now - startTime < checkIntervalMs) {
        const timeRemaining = checkIntervalMs - (now - startTime);
        const sleepPlan = {
          type: "Sleep",
          param: {
            timeMs: timeRemaining
          },
          locate: null
        };
        const { tasks: sleepTasks } = await this.convertPlanToExecutable([
          sleepPlan
        ]);
        await taskExecutor.append(
          this.prependExecutorWithScreenshot(sleepTasks[0])
        );
        await taskExecutor.flush();
      }
    }
    return this.appendErrorPlan(
      taskExecutor,
      `waitFor timeout: ${errorThought}`
    );
  }
};

// src/common/plan-builder.ts
var import_utils9 = require("@midscene/shared/utils");
var debug2 = (0, import_utils9.getDebug)("plan-builder");
function buildPlans(type, locate, param) {
  let returnPlans = [];
  const locatePlan = locate ? {
    type: "Locate",
    locate,
    param: locate,
    thought: ""
  } : null;
  if (type === "Tap" || type === "Hover") {
    (0, import_utils9.assert)(locatePlan, `missing locate info for action "${type}"`);
    const tapPlan = {
      type,
      param: null,
      thought: "",
      locate
    };
    returnPlans = [locatePlan, tapPlan];
  }
  if (type === "Input" || type === "KeyboardPress") {
    if (type === "Input") {
      (0, import_utils9.assert)(locatePlan, `missing locate info for action "${type}"`);
    }
    (0, import_utils9.assert)(param, `missing param for action "${type}"`);
    const inputPlan = {
      type,
      param,
      thought: "",
      locate
    };
    if (locatePlan) {
      returnPlans = [locatePlan, inputPlan];
    } else {
      returnPlans = [inputPlan];
    }
  }
  if (type === "Scroll") {
    (0, import_utils9.assert)(param, `missing param for action "${type}"`);
    const scrollPlan = {
      type,
      param,
      thought: "",
      locate
    };
    if (locatePlan) {
      returnPlans = [locatePlan, scrollPlan];
    } else {
      returnPlans = [scrollPlan];
    }
  }
  if (type === "Sleep") {
    (0, import_utils9.assert)(param, `missing param for action "${type}"`);
    const sleepPlan = {
      type,
      param,
      thought: "",
      locate: null
    };
    returnPlans = [sleepPlan];
  }
  if (returnPlans) {
    debug2("buildPlans", returnPlans);
    return returnPlans;
  }
  throw new Error(`Not supported type: ${type}`);
}

// src/common/agent.ts
var PageAgent = class {
  constructor(page, opts) {
    /**
     * If true, the agent will not perform any actions
     */
    this.dryMode = false;
    this.page = page;
    this.opts = Object.assign(
      {
        generateReport: true,
        autoPrintReportMsg: true,
        groupName: "Midscene Report",
        groupDescription: ""
      },
      opts || {}
    );
    this.insight = new import_core2.Insight(
      async (action) => {
        return this.getUIContext(action);
      },
      {
        generateElement: ({ content, rect }) => new WebElementInfo({
          content: content || "",
          rect,
          id: "",
          attributes: {
            nodeType: import_constants2.NodeType.CONTAINER
          },
          indexId: 0
        })
      }
    );
    this.taskExecutor = new PageTaskExecutor(this.page, this.insight, {
      cacheId: opts?.cacheId
    });
    this.dump = this.resetDump();
    this.reportFileName = reportFileName(opts?.testId || "web");
  }
  async getUIContext(action) {
    if (action && (action === "extract" || action === "assert")) {
      return await parseContextFromWebPage(this.page, {
        ignoreMarker: true
      });
    }
    return await parseContextFromWebPage(this.page, {
      ignoreMarker: !!(0, import_env3.vlLocateMode)()
    });
  }
  resetDump() {
    this.dump = {
      groupName: this.opts.groupName,
      groupDescription: this.opts.groupDescription,
      executions: []
    };
    return this.dump;
  }
  appendExecutionDump(execution) {
    const currentDump = this.dump;
    currentDump.executions.push(execution);
  }
  dumpDataString() {
    this.dump.groupName = this.opts.groupName;
    this.dump.groupDescription = this.opts.groupDescription;
    return (0, import_utils10.stringifyDumpData)(this.dump);
  }
  reportHTMLString() {
    return (0, import_utils10.reportHTMLContent)(this.dumpDataString());
  }
  writeOutActionDumps() {
    const { generateReport, autoPrintReportMsg } = this.opts;
    this.reportFile = (0, import_utils10.writeLogFile)({
      fileName: this.reportFileName,
      fileExt: import_utils10.groupedActionDumpFileExt,
      fileContent: this.dumpDataString(),
      type: "dump",
      generateReport
    });
    if (generateReport && autoPrintReportMsg && this.reportFile) {
      printReportMsg(this.reportFile);
    }
  }
  async callbackOnTaskStartTip(task) {
    if (this.opts.onTaskStartTip) {
      const param = paramStr(task);
      if (param) {
        const tip = `${typeStr(task)} - ${param}`;
        await this.opts.onTaskStartTip(tip);
      } else {
        await this.opts.onTaskStartTip(typeStr(task));
      }
    }
  }
  afterTaskRunning(executor, doNotThrowError = false) {
    this.appendExecutionDump(executor.dump());
    this.writeOutActionDumps();
    if (executor.isInErrorState() && !doNotThrowError) {
      const errorTask = executor.latestErrorTask();
      throw new Error(`${errorTask?.error}
${errorTask?.errorStack}`);
    }
  }
  async aiTap(targetPrompt, searchArea) {
    const plans = buildPlans("Tap", {
      prompt: targetPrompt,
      searchArea
    });
    const { executor, output } = await this.taskExecutor.runPlans(
      `Tap ${targetPrompt}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiHover(taskPrompt) {
    const plans = buildPlans("Hover", {
      prompt: taskPrompt
    });
    const { executor, output } = await this.taskExecutor.runPlans(
      `Hover ${taskPrompt}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiInput(where, value) {
    const plans = buildPlans(
      "Input",
      {
        prompt: where
      },
      {
        value
      }
    );
    const { executor, output } = await this.taskExecutor.runPlans(
      `Input ${where} - ${value}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiKeyboardPress(where, value) {
    const plans = buildPlans(
      "KeyboardPress",
      {
        prompt: where
      },
      {
        value
      }
    );
    const { executor, output } = await this.taskExecutor.runPlans(
      `KeyboardPress ${where} - ${value}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  // async aiScroll(where: string, param: PlanningActionParamScroll) {
  //   const plans = buildPlans(
  //     'Scroll',
  //     {
  //       prompt: where,
  //     },
  //     param,
  //   );
  //   const { executor, output } = await this.taskExecutor.runPlans(
  //     `Scroll ${where} - ${paramStr(param)}`,
  //     plans,
  //   );
  // }
  async aiAction(taskPrompt) {
    const { executor } = await ((0, import_env3.getAIConfig)(import_env3.MIDSCENE_USE_VLM_UI_TARS) ? this.taskExecutor.actionToGoal(taskPrompt, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    }) : this.taskExecutor.action(taskPrompt, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    }));
    this.afterTaskRunning(executor);
  }
  async aiQuery(demand) {
    const { output, executor } = await this.taskExecutor.query(demand, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.afterTaskRunning(executor);
    return output;
  }
  async aiAssert(assertion, msg, opt) {
    const { output, executor } = await this.taskExecutor.assert(assertion, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.afterTaskRunning(executor, true);
    if (output && opt?.keepRawResponse) {
      return output;
    }
    if (!output?.pass) {
      const errMsg = msg || `Assertion failed: ${assertion}`;
      const reasonMsg = `Reason: ${output?.thought || executor.latestErrorTask()?.error || "(no_reason)"}`;
      throw new Error(`${errMsg}
${reasonMsg}`);
    }
  }
  async aiWaitFor(assertion, opt) {
    const { executor } = await this.taskExecutor.waitFor(assertion, {
      timeoutMs: opt?.timeoutMs || 15 * 1e3,
      checkIntervalMs: opt?.checkIntervalMs || 3 * 1e3,
      assertion,
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.appendExecutionDump(executor.dump());
    this.writeOutActionDumps();
    if (executor.isInErrorState()) {
      const errorTask = executor.latestErrorTask();
      throw new Error(`${errorTask?.error}
${errorTask?.errorStack}`);
    }
  }
  async ai(taskPrompt, type = "action") {
    if (type === "action") {
      return this.aiAction(taskPrompt);
    }
    if (type === "query") {
      return this.aiQuery(taskPrompt);
    }
    if (type === "assert") {
      return this.aiAssert(taskPrompt);
    }
    throw new Error(
      `Unknown type: ${type}, only support 'action', 'query', 'assert'`
    );
  }
  async runYaml(yamlScriptContent) {
    const script = parseYamlScript(yamlScriptContent, "yaml", true);
    const player = new ScriptPlayer(script, async (target) => {
      return { agent: this, freeFn: [] };
    });
    await player.run();
    if (player.status === "error") {
      const errors = player.taskStatusList.filter((task) => task.status === "error").map((task) => {
        return `task - ${task.name}: ${task.error?.message}`;
      }).join("\n");
      throw new Error(`Error(s) occurred in running yaml script:
${errors}`);
    }
    return {
      result: player.result
    };
  }
  async destroy() {
    await this.page.destroy();
  }
};

// src/chrome-extension/agent.ts
var ChromeExtensionProxyPageAgent = class extends PageAgent {
  constructor(page) {
    super(page, {});
  }
};

// src/chrome-extension/page.ts
var import_extractor2 = require("@midscene/shared/extractor");
var import_utils15 = require("@midscene/shared/utils");

// src/chrome-extension/cdpInput.ts
var import_keyboard_layout = require("@midscene/shared/keyboard-layout");
var import_utils13 = require("@midscene/shared/utils");
var _pressedKeys, _client, _modifierBit, modifierBit_fn, _keyDescriptionForString, keyDescriptionForString_fn;
var CdpKeyboard = class {
  constructor(client) {
    __privateAdd(this, _modifierBit);
    __privateAdd(this, _keyDescriptionForString);
    __privateAdd(this, _pressedKeys, /* @__PURE__ */ new Set());
    __privateAdd(this, _client, void 0);
    this._modifiers = 0;
    __privateSet(this, _client, client);
  }
  updateClient(client) {
    __privateSet(this, _client, client);
  }
  async down(key, options = {
    text: void 0,
    commands: []
  }) {
    const description = __privateMethod(this, _keyDescriptionForString, keyDescriptionForString_fn).call(this, key);
    const autoRepeat = __privateGet(this, _pressedKeys).has(description.code);
    __privateGet(this, _pressedKeys).add(description.code);
    this._modifiers |= __privateMethod(this, _modifierBit, modifierBit_fn).call(this, description.key);
    const text = options.text === void 0 ? description.text : options.text;
    await __privateGet(this, _client).send("Input.dispatchKeyEvent", {
      type: text ? "keyDown" : "rawKeyDown",
      modifiers: this._modifiers,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      key: description.key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location: description.location,
      isKeypad: description.location === 3,
      commands: options.commands
    });
  }
  async up(key) {
    const description = __privateMethod(this, _keyDescriptionForString, keyDescriptionForString_fn).call(this, key);
    this._modifiers &= ~__privateMethod(this, _modifierBit, modifierBit_fn).call(this, description.key);
    __privateGet(this, _pressedKeys).delete(description.code);
    await __privateGet(this, _client).send("Input.dispatchKeyEvent", {
      type: "keyUp",
      modifiers: this._modifiers,
      key: description.key,
      windowsVirtualKeyCode: description.keyCode,
      code: description.code,
      location: description.location
    });
  }
  async sendCharacter(char) {
    await __privateGet(this, _client).send("Input.insertText", { text: char });
  }
  charIsKey(char) {
    return !!import_keyboard_layout._keyDefinitions[char];
  }
  async type(text, options = {}) {
    const delay = options.delay || void 0;
    for (const char of text) {
      if (this.charIsKey(char)) {
        await this.press(char, { delay });
      } else {
        if (delay) {
          await new Promise((f) => {
            return setTimeout(f, delay);
          });
        }
        await this.sendCharacter(char);
      }
    }
  }
  async press(key, options = {}) {
    const { delay = null } = options;
    const keys = Array.isArray(key) ? key : [key];
    for (const k of keys) {
      await this.down(k, options);
    }
    if (delay) {
      await new Promise((f) => {
        return setTimeout(f, options.delay);
      });
    }
    for (const k of [...keys].reverse()) {
      await this.up(k);
    }
  }
};
_pressedKeys = new WeakMap();
_client = new WeakMap();
_modifierBit = new WeakSet();
modifierBit_fn = function(key) {
  if (key === "Alt") {
    return 1;
  }
  if (key === "Control") {
    return 2;
  }
  if (key === "Meta") {
    return 4;
  }
  if (key === "Shift") {
    return 8;
  }
  return 0;
};
_keyDescriptionForString = new WeakSet();
keyDescriptionForString_fn = function(keyString) {
  const shift = this._modifiers & 8;
  const description = {
    key: "",
    keyCode: 0,
    code: "",
    text: "",
    location: 0
  };
  const definition = import_keyboard_layout._keyDefinitions[keyString];
  (0, import_utils13.assert)(definition, `Unknown key: "${keyString}"`);
  if (definition.key) {
    description.key = definition.key;
  }
  if (shift && definition.shiftKey) {
    description.key = definition.shiftKey;
  }
  if (definition.keyCode) {
    description.keyCode = definition.keyCode;
  }
  if (shift && definition.shiftKeyCode) {
    description.keyCode = definition.shiftKeyCode;
  }
  if (definition.code) {
    description.code = definition.code;
  }
  if (definition.location) {
    description.location = definition.location;
  }
  if (description.key.length === 1) {
    description.text = description.key;
  }
  if (definition.text) {
    description.text = definition.text;
  }
  if (shift && definition.shiftText) {
    description.text = definition.shiftText;
  }
  if (this._modifiers & ~8) {
    description.text = "";
  }
  return description;
};

// src/chrome-extension/dynamic-scripts.ts
var import_node_fs3 = __toESM(require("fs"));
var import_utils14 = require("@midscene/shared/utils");
var scriptFileContentCache = null;
var getHtmlElementScript = async () => {
  const scriptFileToRetrieve = chrome.runtime.getURL("scripts/htmlElement.js");
  if (scriptFileContentCache)
    return scriptFileContentCache;
  if (import_utils14.ifInBrowser) {
    const script = await fetch(scriptFileToRetrieve);
    scriptFileContentCache = await script.text();
    return scriptFileContentCache;
  }
  return import_node_fs3.default.readFileSync(scriptFileToRetrieve, "utf8");
};
var waterFlowScriptFileContentCache = null;
var injectWaterFlowAnimation = async () => {
  const waterFlowScriptFileToRetrieve = chrome.runtime.getURL(
    "scripts/water-flow.js"
  );
  if (waterFlowScriptFileContentCache)
    return waterFlowScriptFileContentCache;
  if (import_utils14.ifInBrowser) {
    const script = await fetch(waterFlowScriptFileToRetrieve);
    waterFlowScriptFileContentCache = await script.text();
    return waterFlowScriptFileContentCache;
  }
  return import_node_fs3.default.readFileSync(waterFlowScriptFileToRetrieve, "utf8");
};
var stopWaterFlowScriptFileContentCache = null;
var injectStopWaterFlowAnimation = async () => {
  const stopWaterFlowScriptFileToRetrieve = chrome.runtime.getURL(
    "scripts/stop-water-flow.js"
  );
  if (stopWaterFlowScriptFileContentCache)
    return stopWaterFlowScriptFileContentCache;
  if (import_utils14.ifInBrowser) {
    const script = await fetch(stopWaterFlowScriptFileToRetrieve);
    stopWaterFlowScriptFileContentCache = await script.text();
    return stopWaterFlowScriptFileContentCache;
  }
  return import_node_fs3.default.readFileSync(stopWaterFlowScriptFileToRetrieve, "utf8");
};

// src/chrome-extension/page.ts
function sleep2(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var ChromeExtensionProxyPage = class {
  constructor(forceSameTabNavigation) {
    this.pageType = "chrome-extension-proxy";
    this.version = "0.12.8";
    this.activeTabId = null;
    this.tabIdOfDebuggerAttached = null;
    this.attachingDebugger = null;
    this.destroyed = false;
    this.latestMouseX = 100;
    this.latestMouseY = 100;
    this.mouse = {
      click: async (x, y) => {
        await this.showMousePointer(x, y);
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mousePressed",
          x,
          y,
          button: "left",
          clickCount: 1
        });
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          x,
          y,
          button: "left",
          clickCount: 1
        });
      },
      wheel: async (deltaX, deltaY, startX, startY) => {
        const finalX = startX || this.latestMouseX;
        const finalY = startY || this.latestMouseY;
        await this.showMousePointer(finalX, finalY);
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mouseWheel",
          x: finalX,
          y: finalY,
          deltaX,
          deltaY
        });
        this.latestMouseX = finalX;
        this.latestMouseY = finalY;
      },
      move: async (x, y) => {
        await this.showMousePointer(x, y);
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mouseMoved",
          x,
          y
        });
        this.latestMouseX = x;
        this.latestMouseY = y;
      },
      drag: async (from, to) => {
        await this.mouse.move(from.x, from.y);
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mousePressed",
          x: from.x,
          y: from.y,
          button: "left",
          clickCount: 1
        });
        await this.mouse.move(to.x, to.y);
        await this.sendCommandToDebugger("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          x: to.x,
          y: to.y,
          button: "left",
          clickCount: 1
        });
      }
    };
    this.keyboard = {
      type: async (text) => {
        const cdpKeyboard = new CdpKeyboard({
          send: this.sendCommandToDebugger.bind(this)
        });
        await cdpKeyboard.type(text, { delay: 0 });
      },
      press: async (action) => {
        const cdpKeyboard = new CdpKeyboard({
          send: this.sendCommandToDebugger.bind(this)
        });
        const keys = Array.isArray(action) ? action : [action];
        for (const k of keys) {
          const commands = k.command ? [k.command] : [];
          await cdpKeyboard.down(k.key, { commands });
        }
        for (const k of [...keys].reverse()) {
          await cdpKeyboard.up(k.key);
        }
      }
    };
    this.forceSameTabNavigation = forceSameTabNavigation;
  }
  async setActiveTabId(tabId) {
    if (this.activeTabId) {
      throw new Error(
        `Active tab id is already set, which is ${this.activeTabId}, cannot set it to ${tabId}`
      );
    }
    this.activeTabId = tabId;
  }
  async getActiveTabId() {
    return this.activeTabId;
  }
  async getTabIdOrConnectToCurrentTab() {
    if (this.activeTabId) {
      return this.activeTabId;
    }
    const tabId = await chrome.tabs.query({ active: true, currentWindow: true }).then((tabs) => tabs[0]?.id);
    this.activeTabId = tabId || 0;
    return this.activeTabId;
  }
  async attachDebugger() {
    (0, import_utils15.assert)(!this.destroyed, "Page is destroyed");
    if (this.attachingDebugger) {
      await this.attachingDebugger;
      return;
    }
    this.attachingDebugger = (async () => {
      const url = await this.url();
      let error = null;
      if (url.startsWith("chrome://")) {
        throw new Error(
          "Cannot attach debugger to chrome:// pages, please use Midscene in a normal page with http://, https:// or file://"
        );
      }
      try {
        const currentTabId = await this.getTabIdOrConnectToCurrentTab();
        if (this.tabIdOfDebuggerAttached === currentTabId) {
          return;
        }
        if (this.tabIdOfDebuggerAttached && this.tabIdOfDebuggerAttached !== currentTabId) {
          console.log(
            "detach the previous tab",
            this.tabIdOfDebuggerAttached,
            "->",
            currentTabId
          );
          try {
            await this.detachDebugger(this.tabIdOfDebuggerAttached);
          } catch (error2) {
            console.error("Failed to detach debugger", error2);
          }
        }
        console.log("attaching debugger", currentTabId);
        await chrome.debugger.attach({ tabId: currentTabId }, "1.3");
        await sleep2(500);
        this.tabIdOfDebuggerAttached = currentTabId;
        await this.enableWaterFlowAnimation();
      } catch (e) {
        console.error("Failed to attach debugger", e);
        error = e;
      } finally {
        this.attachingDebugger = null;
      }
      if (error) {
        throw error;
      }
    })();
    await this.attachingDebugger;
  }
  async showMousePointer(x, y) {
    const pointerScript = `(() => {
      if(typeof window.midsceneWaterFlowAnimation !== 'undefined') {
        window.midsceneWaterFlowAnimation.enable();
        window.midsceneWaterFlowAnimation.showMousePointer(${x}, ${y});
      } else {
        console.log('midsceneWaterFlowAnimation is not defined');
      }
    })()`;
    await this.sendCommandToDebugger("Runtime.evaluate", {
      expression: `${pointerScript}`
    });
  }
  async hideMousePointer() {
    await this.sendCommandToDebugger("Runtime.evaluate", {
      expression: `(() => {
        if(typeof window.midsceneWaterFlowAnimation !== 'undefined') {
          window.midsceneWaterFlowAnimation.hideMousePointer();
        }
      })()`
    });
  }
  async detachDebugger(tabId) {
    const tabIdToDetach = tabId || this.tabIdOfDebuggerAttached;
    console.log("detaching debugger", tabIdToDetach);
    if (!tabIdToDetach) {
      console.warn("No tab id to detach");
      return;
    }
    try {
      await this.disableWaterFlowAnimation(tabIdToDetach);
      await sleep2(200);
    } catch (error) {
      console.warn("Failed to disable water flow animation", error);
    }
    try {
      await chrome.debugger.detach({ tabId: tabIdToDetach });
    } catch (error) {
      console.warn("Failed to detach debugger", error);
    }
    this.tabIdOfDebuggerAttached = null;
  }
  async enableWaterFlowAnimation() {
    if (this.forceSameTabNavigation) {
      await chrome.debugger.sendCommand(
        { tabId: this.tabIdOfDebuggerAttached },
        "Runtime.evaluate",
        {
          expression: limitOpenNewTabScript
        }
      );
    }
    const script = await injectWaterFlowAnimation();
    await chrome.debugger.sendCommand(
      { tabId: this.tabIdOfDebuggerAttached },
      "Runtime.evaluate",
      {
        expression: script
      }
    );
  }
  async disableWaterFlowAnimation(tabId) {
    const script = await injectStopWaterFlowAnimation();
    await chrome.debugger.sendCommand({ tabId }, "Runtime.evaluate", {
      expression: script
    });
  }
  async sendCommandToDebugger(command, params) {
    await this.attachDebugger();
    (0, import_utils15.assert)(this.tabIdOfDebuggerAttached, "Debugger is not attached");
    this.enableWaterFlowAnimation();
    return await chrome.debugger.sendCommand(
      { tabId: this.tabIdOfDebuggerAttached },
      command,
      params
    );
  }
  async getPageContentByCDP() {
    const script = await getHtmlElementScript();
    await this.sendCommandToDebugger("Runtime.evaluate", {
      expression: script
    });
    const expression = () => {
      return {
        tree: window.midscene_element_inspector.webExtractNodeTree(),
        size: {
          width: document.documentElement.clientWidth,
          height: document.documentElement.clientHeight,
          dpr: window.devicePixelRatio
        }
      };
    };
    const returnValue = await this.sendCommandToDebugger("Runtime.evaluate", {
      expression: `(${expression.toString()})()`,
      returnByValue: true
    });
    if (!returnValue.result.value) {
      const errorDescription = returnValue.exceptionDetails?.exception?.description || "";
      if (!errorDescription) {
        console.error("returnValue from cdp", returnValue);
      }
      throw new Error(
        `Failed to get page content from page, error: ${errorDescription}`
      );
    }
    return returnValue.result.value;
  }
  // current implementation is wait until domReadyState is complete
  async waitUntilNetworkIdle() {
    const timeout = 1e4;
    const startTime = Date.now();
    let lastReadyState = "";
    while (Date.now() - startTime < timeout) {
      const result = await this.sendCommandToDebugger("Runtime.evaluate", {
        expression: "document.readyState"
      });
      lastReadyState = result.result.value;
      if (lastReadyState === "complete") {
        await new Promise((resolve) => setTimeout(resolve, 300));
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, 300));
    }
    throw new Error(
      `Failed to wait until network idle, last readyState: ${lastReadyState}`
    );
  }
  async getElementsInfo() {
    const tree = await this.getElementsNodeTree();
    return (0, import_extractor2.treeToList)(tree);
  }
  async getElementsNodeTree() {
    await this.hideMousePointer();
    const content = await this.getPageContentByCDP();
    if (content?.size) {
      this.viewportSize = content.size;
    }
    return content?.tree || { node: null, children: [] };
  }
  async size() {
    if (this.viewportSize)
      return this.viewportSize;
    const content = await this.getPageContentByCDP();
    return content.size;
  }
  async screenshotBase64() {
    await this.hideMousePointer();
    const base64 = await this.sendCommandToDebugger("Page.captureScreenshot", {
      format: "jpeg",
      quality: 90
    });
    return `data:image/jpeg;base64,${base64.data}`;
  }
  async url() {
    const tabId = await this.getTabIdOrConnectToCurrentTab();
    const url = await chrome.tabs.get(tabId).then((tab) => tab.url);
    return url || "";
  }
  async scrollUntilTop(startingPoint) {
    if (startingPoint) {
      await this.mouse.move(startingPoint.left, startingPoint.top);
    }
    return this.mouse.wheel(0, -9999999);
  }
  async scrollUntilBottom(startingPoint) {
    if (startingPoint) {
      await this.mouse.move(startingPoint.left, startingPoint.top);
    }
    return this.mouse.wheel(0, 9999999);
  }
  async scrollUntilLeft(startingPoint) {
    if (startingPoint) {
      await this.mouse.move(startingPoint.left, startingPoint.top);
    }
    return this.mouse.wheel(-9999999, 0);
  }
  async scrollUntilRight(startingPoint) {
    if (startingPoint) {
      await this.mouse.move(startingPoint.left, startingPoint.top);
    }
    return this.mouse.wheel(9999999, 0);
  }
  async scrollUp(distance, startingPoint) {
    const { height } = await this.size();
    const scrollDistance = distance || height * 0.7;
    return this.mouse.wheel(
      0,
      -scrollDistance,
      startingPoint?.left,
      startingPoint?.top
    );
  }
  async scrollDown(distance, startingPoint) {
    const { height } = await this.size();
    const scrollDistance = distance || height * 0.7;
    return this.mouse.wheel(
      0,
      scrollDistance,
      startingPoint?.left,
      startingPoint?.top
    );
  }
  async scrollLeft(distance, startingPoint) {
    const { width } = await this.size();
    const scrollDistance = distance || width * 0.7;
    return this.mouse.wheel(
      -scrollDistance,
      0,
      startingPoint?.left,
      startingPoint?.top
    );
  }
  async scrollRight(distance, startingPoint) {
    const { width } = await this.size();
    const scrollDistance = distance || width * 0.7;
    return this.mouse.wheel(
      scrollDistance,
      0,
      startingPoint?.left,
      startingPoint?.top
    );
  }
  async clearInput(element) {
    if (!element) {
      console.warn("No element to clear input");
      return;
    }
    await this.mouse.click(element.center[0], element.center[1]);
    await this.sendCommandToDebugger("Input.dispatchKeyEvent", {
      type: "keyDown",
      commands: ["selectAll"]
    });
    await this.sendCommandToDebugger("Input.dispatchKeyEvent", {
      type: "keyUp",
      commands: ["selectAll"]
    });
    await sleep2(100);
    await this.keyboard.press({
      key: "Backspace"
    });
  }
  async destroy() {
    this.activeTabId = null;
    await this.detachDebugger();
    this.destroyed = true;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChromeExtensionProxyPage,
  ChromeExtensionProxyPageAgent,
  ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED
});
/**
 * @license
 * Copyright 2017 Google Inc.
 * SPDX-License-Identifier: Apache-2.0
 */

//# sourceMappingURL=chrome-extension.js.map