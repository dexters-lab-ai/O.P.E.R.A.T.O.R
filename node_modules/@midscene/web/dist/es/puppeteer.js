// src/common/agent.ts
import {
  Insight
} from "@midscene/core";
import { NodeType as NodeType2 } from "@midscene/shared/constants";

// src/yaml/player.ts
import { existsSync, mkdirSync, writeFileSync } from "fs";
import { dirname, join } from "path";
import { assert } from "@midscene/shared/utils";
var ScriptPlayer = class {
  constructor(script, setupAgent, onTaskStatusChange) {
    this.script = script;
    this.setupAgent = setupAgent;
    this.onTaskStatusChange = onTaskStatusChange;
    this.taskStatusList = [];
    this.status = "init";
    this.unnamedResultIndex = 0;
    this.pageAgent = null;
    this.result = {};
    this.output = script.target?.output;
    this.taskStatusList = (script.tasks || []).map((task, taskIndex) => ({
      ...task,
      index: taskIndex,
      status: "init",
      totalSteps: task.flow?.length || 0
    }));
  }
  setPlayerStatus(status, error) {
    this.status = status;
    this.errorInSetup = error;
  }
  notifyCurrentTaskStatusChange(taskIndex) {
    const taskIndexToNotify = typeof taskIndex === "number" ? taskIndex : this.currentTaskIndex;
    if (typeof taskIndexToNotify !== "number") {
      return;
    }
    const taskStatus = this.taskStatusList[taskIndexToNotify];
    if (this.onTaskStatusChange) {
      this.onTaskStatusChange(taskStatus);
    }
  }
  async setTaskStatus(index, statusValue, error) {
    this.taskStatusList[index].status = statusValue;
    if (error) {
      this.taskStatusList[index].error = error;
    }
    this.notifyCurrentTaskStatusChange(index);
  }
  setTaskIndex(taskIndex) {
    this.currentTaskIndex = taskIndex;
  }
  flushResult() {
    if (Object.keys(this.result).length && this.output) {
      const output = join(process.cwd(), this.output);
      const outputDir = dirname(output);
      if (!existsSync(outputDir)) {
        mkdirSync(outputDir, { recursive: true });
      }
      writeFileSync(output, JSON.stringify(this.result, void 0, 2));
    }
  }
  async playTask(taskStatus, agent) {
    const { flow } = taskStatus;
    assert(flow, "missing flow in task");
    for (const flowItemIndex in flow) {
      const currentStep = Number.parseInt(flowItemIndex, 10);
      taskStatus.currentStep = currentStep;
      const flowItem = flow[flowItemIndex];
      if (flowItem.aiAction || flowItem.ai) {
        const actionTask = flowItem;
        const prompt = actionTask.aiAction || actionTask.ai;
        assert(prompt, "missing prompt for ai (aiAction)");
        assert(
          typeof prompt === "string",
          "prompt for aiAction must be a string"
        );
        await agent.aiAction(prompt);
      } else if (flowItem.aiAssert) {
        const assertTask = flowItem;
        const prompt = assertTask.aiAssert;
        assert(prompt, "missing prompt for aiAssert");
        assert(
          typeof prompt === "string",
          "prompt for aiAssert must be a string"
        );
        await agent.aiAssert(prompt);
      } else if (flowItem.aiQuery) {
        const queryTask = flowItem;
        const prompt = queryTask.aiQuery;
        assert(prompt, "missing prompt for aiQuery");
        assert(
          typeof prompt === "string",
          "prompt for aiQuery must be a string"
        );
        const queryResult = await agent.aiQuery(prompt);
        const resultKey = queryTask.name || this.unnamedResultIndex++;
        if (this.result[resultKey]) {
          console.warn(
            `result key ${resultKey} already exists, will overwrite`
          );
        }
        this.result[resultKey] = queryResult;
        this.flushResult();
      } else if (flowItem.aiWaitFor) {
        const waitForTask = flowItem;
        const prompt = waitForTask.aiWaitFor;
        assert(prompt, "missing prompt for aiWaitFor");
        assert(
          typeof prompt === "string",
          "prompt for aiWaitFor must be a string"
        );
        const timeout = waitForTask.timeout;
        await agent.aiWaitFor(prompt, { timeoutMs: timeout });
      } else if (flowItem.sleep) {
        const sleepTask = flowItem;
        const ms = sleepTask.sleep;
        let msNumber = ms;
        if (typeof ms === "string") {
          msNumber = Number.parseInt(ms, 10);
        }
        assert(
          msNumber && msNumber > 0,
          `ms for sleep must be greater than 0, but got ${ms}`
        );
        await new Promise((resolve) => setTimeout(resolve, msNumber));
      } else {
        throw new Error(`unknown flowItem: ${JSON.stringify(flowItem)}`);
      }
    }
    this.reportFile = agent.reportFile;
  }
  async run() {
    const { target, tasks } = this.script;
    this.setPlayerStatus("running");
    let agent = null;
    let freeFn = [];
    try {
      const { agent: newAgent, freeFn: newFreeFn } = await this.setupAgent(target);
      agent = newAgent;
      freeFn = newFreeFn;
    } catch (e) {
      this.setPlayerStatus("error", e);
      return;
    }
    this.pageAgent = agent;
    let taskIndex = 0;
    this.setPlayerStatus("running");
    let errorFlag = false;
    while (taskIndex < tasks.length) {
      const taskStatus = this.taskStatusList[taskIndex];
      this.setTaskStatus(taskIndex, "running");
      this.setTaskIndex(taskIndex);
      try {
        await this.playTask(taskStatus, this.pageAgent);
        this.setTaskStatus(taskIndex, "done");
      } catch (e) {
        this.setTaskStatus(taskIndex, "error", e);
        if (taskStatus.continueOnError) {
        } else {
          this.reportFile = agent.reportFile;
          errorFlag = true;
          break;
        }
      }
      this.reportFile = agent.reportFile;
      taskIndex++;
    }
    if (errorFlag) {
      this.setPlayerStatus("error");
    } else {
      this.setPlayerStatus("done");
    }
    for (const fn of freeFn) {
      try {
        await fn.fn();
      } catch (e) {
      }
    }
  }
};

// src/yaml/builder.ts
import yaml from "js-yaml";

// src/yaml/utils.ts
import { assert as assert2 } from "@midscene/shared/utils";
import yaml2 from "js-yaml";
function interpolateEnvVars(content) {
  return content.replace(/\$\{([^}]+)\}/g, (_, envVar) => {
    const value = process.env[envVar.trim()];
    if (value === void 0) {
      throw new Error(`Environment variable "${envVar.trim()}" is not defined`);
    }
    return value;
  });
}
function parseYamlScript(content, filePath, ignoreCheckingTarget) {
  const interpolatedContent = interpolateEnvVars(content);
  const obj = yaml2.load(interpolatedContent);
  const pathTip = filePath ? `, failed to load ${filePath}` : "";
  if (!ignoreCheckingTarget) {
    assert2(
      obj.target,
      `property "target" is required in yaml script${pathTip}`
    );
    assert2(
      typeof obj.target === "object",
      `property "target" must be an object${pathTip}`
    );
  }
  assert2(obj.tasks, `property "tasks" is required in yaml script ${pathTip}`);
  assert2(
    Array.isArray(obj.tasks),
    `property "tasks" must be an array in yaml script, but got ${obj.tasks}`
  );
  return obj;
}

// src/common/agent.ts
import {
  MIDSCENE_USE_VLM_UI_TARS as MIDSCENE_USE_VLM_UI_TARS2,
  getAIConfig as getAIConfig3,
  vlLocateMode
} from "@midscene/core/env";
import {
  groupedActionDumpFileExt,
  reportHTMLContent,
  stringifyDumpData as stringifyDumpData2,
  writeLogFile as writeLogFile2
} from "@midscene/core/utils";

// src/common/tasks.ts
import {
  Executor,
  plan
} from "@midscene/core";
import {
  vlmPlanning
} from "@midscene/core/ai-model";
import { sleep } from "@midscene/core/utils";
import { assert as assert3 } from "@midscene/shared/utils";

// src/common/task-cache.ts
import { existsSync as existsSync2, readFileSync } from "fs";
import { join as join2 } from "path";
import { getAIConfigInBoolean } from "@midscene/core/env";
import {
  getLogDirByType,
  stringifyDumpData,
  writeLogFile
} from "@midscene/core/utils";
import { getRunningPkgInfo } from "@midscene/shared/fs";
import { getDebug, ifInBrowser } from "@midscene/shared/utils";
var debug = getDebug("cache");
var TaskCache = class {
  constructor(opts) {
    this.midscenePkgInfo = getRunningPkgInfo();
    this.cacheId = opts?.cacheId || "";
    this.cache = this.readCacheFromFile() || {
      aiTasks: []
    };
    this.newCache = {
      aiTasks: []
    };
  }
  getCacheGroupByPrompt(aiActionPrompt) {
    const { aiTasks = [] } = this.cache || { aiTasks: [] };
    const index = aiTasks.findIndex((item) => item.prompt === aiActionPrompt);
    const newCacheGroup = [];
    this.newCache.aiTasks.push({
      prompt: aiActionPrompt,
      tasks: newCacheGroup
    });
    return {
      matchCache: (pageContext, type, actionPrompt) => {
        if (index === -1) {
          return false;
        }
        if (type === "plan") {
          return this.matchCache(
            pageContext,
            type,
            actionPrompt,
            aiTasks[index].tasks
          );
        }
        if (type === "ui-tars-plan") {
          return this.matchCache(
            pageContext,
            type,
            actionPrompt,
            aiTasks[index].tasks
          );
        }
        return this.matchCache(
          pageContext,
          type,
          actionPrompt,
          aiTasks[index].tasks
        );
      },
      saveCache: (cache) => {
        newCacheGroup.push(cache);
        debug(
          "saving cache to file, type: %s, cacheId: %s",
          cache.type,
          this.cacheId
        );
        this.writeCacheToFile();
      }
    };
  }
  matchCache(pageContext, type, userPrompt, cacheGroup) {
    debug(
      "will read cache, type: %s, prompt: %s, cacheGroupLength: %s",
      type,
      userPrompt,
      cacheGroup.length
    );
    if (cacheGroup.length > 0) {
      const index = cacheGroup.findIndex((item) => item.prompt === userPrompt);
      if (index === -1) {
        debug("cannot find any cache matching prompt: %s", userPrompt);
        return false;
      }
      const taskRes = cacheGroup.splice(index, 1)[0];
      debug(
        "found cache with same prompt, type: %s, prompt: %s, cached response is %j",
        type,
        userPrompt,
        taskRes?.response
      );
      if (taskRes?.type === "locate") {
        const id = taskRes.response?.elements[0].id;
        if (!id) {
          debug("no id in cached response");
          return false;
        }
        const foundInContext = pageContext.content.find(
          (contentElement) => contentElement.id === id
        );
        if (!foundInContext) {
          debug("cannot match element with same id in current page");
          return false;
        }
        return taskRes.response;
      }
      if (taskRes && taskRes.type === type && taskRes.prompt === userPrompt) {
        const contextEqual = this.pageContextEqual(
          taskRes.pageContext,
          pageContext
        );
        if (!contextEqual) {
          debug(
            "cache almost hit, type: %s, prompt: %s, but context not equal, will not use cache",
            type,
            userPrompt
          );
          return false;
        }
        debug("cache hit, type: %s, prompt: %s", type, userPrompt);
        return taskRes.response;
      }
    }
    debug("no cache hit, type: %s, prompt: %s", type, userPrompt);
    return false;
  }
  pageContextEqual(taskPageContext, pageContext) {
    debug(
      "comparing page context size: %s x %s, %s x %s",
      taskPageContext.size.width,
      taskPageContext.size.height,
      pageContext.size.width,
      pageContext.size.height
    );
    return taskPageContext.size.width === pageContext.size.width && taskPageContext.size.height === pageContext.size.height;
  }
  /**
   * Generate task cache data.
   * This method is mainly used to create or obtain some cached data for tasks, and it returns a new cache object.
   * In the cache object, it may contain task-related information, states, or other necessary data.
   * It is assumed that the `newCache` property already exists in the current class or object and is a data structure used to store task cache.
   * @returns {Object} Returns a new cache object, which may include task cache data.
   */
  generateTaskCache() {
    return this.newCache;
  }
  readCacheFromFile() {
    if (ifInBrowser || !this.cacheId) {
      return void 0;
    }
    const cacheFile = join2(getLogDirByType("cache"), `${this.cacheId}.json`);
    if (!getAIConfigInBoolean("MIDSCENE_CACHE")) {
      return void 0;
    }
    if (existsSync2(cacheFile)) {
      try {
        const data = readFileSync(cacheFile, "utf8");
        const jsonData = JSON.parse(data);
        if (!this.midscenePkgInfo) {
          return void 0;
        }
        const jsonDataPkgVersion = jsonData.pkgVersion.split(".");
        const midscenePkgInfoPkgVersion = this.midscenePkgInfo.version.split(".");
        if (jsonDataPkgVersion[0] !== midscenePkgInfoPkgVersion[0] || jsonDataPkgVersion[1] !== midscenePkgInfoPkgVersion[1]) {
          return void 0;
        }
        debug("read cache from file: %s", cacheFile);
        return jsonData;
      } catch (err) {
        debug(
          "cache file exists but parse failed, path: %s, error: %s",
          cacheFile,
          err
        );
        return void 0;
      }
    }
    debug("no cache file found, path: %s", cacheFile);
    return void 0;
  }
  writeCacheToFile() {
    const midscenePkgInfo = getRunningPkgInfo();
    if (!midscenePkgInfo) {
      debug("no midscene pkg info, will not write cache to file");
      return;
    }
    if (!this.cacheId) {
      debug("no cache id, will not write cache to file");
      return;
    }
    if (!ifInBrowser) {
      writeLogFile({
        fileName: `${this.cacheId}`,
        fileExt: "json",
        fileContent: stringifyDumpData(
          {
            pkgName: midscenePkgInfo.name,
            pkgVersion: midscenePkgInfo.version,
            cacheId: this.cacheId,
            ...this.newCache
          },
          2
        ),
        type: "cache"
      });
    }
  }
};

// src/common/ui-utils.ts
function typeStr(task) {
  return task.subType ? `${task.type} / ${task.subType || ""}` : task.type;
}
function getKeyCommands(value) {
  const keys = Array.isArray(value) ? value : [value];
  return keys.reduce((acc, k) => {
    const includeMeta = keys.includes("Meta") || keys.includes("Control");
    if (includeMeta && (k === "a" || k === "A")) {
      return acc.concat([{ key: k, command: "SelectAll" }]);
    }
    if (includeMeta && (k === "c" || k === "C")) {
      return acc.concat([{ key: k, command: "Copy" }]);
    }
    if (includeMeta && (k === "v" || k === "V")) {
      return acc.concat([{ key: k, command: "Paste" }]);
    }
    return acc.concat([{ key: k }]);
  }, []);
}
function paramStr(task) {
  let value;
  if (task.type === "Planning") {
    value = task?.param?.userInstruction;
  }
  if (task.type === "Insight") {
    value = task?.param?.prompt || task?.param?.id || task?.param?.dataDemand || task?.param?.assertion;
  }
  if (task.type === "Action") {
    const sleepMs = task?.param?.timeMs;
    const scrollType = task?.param?.scrollType;
    if (sleepMs) {
      value = `${sleepMs}ms`;
    } else if (scrollType) {
      const scrollDirection = task?.param?.direction;
      const scrollDistance = task?.param?.distance;
      value = `${scrollDirection || "down"}, ${scrollType || "once"}, ${scrollDistance || "distance-not-set"}`;
    } else {
      value = task?.param?.value || task?.param?.scrollType;
    }
    if (!value) {
      value = task.thought;
    }
  }
  if (typeof value === "undefined")
    return "";
  return typeof value === "string" ? value : JSON.stringify(value, void 0, 2);
}

// src/common/tasks.ts
var replanningCountLimit = 10;
var PageTaskExecutor = class {
  constructor(page, insight, opts) {
    this.conversationHistory = [];
    this.page = page;
    this.insight = insight;
    this.taskCache = new TaskCache({
      cacheId: opts?.cacheId
    });
  }
  async recordScreenshot(timing) {
    const base64 = await this.page.screenshotBase64();
    const item = {
      type: "screenshot",
      ts: Date.now(),
      screenshot: base64,
      timing
    };
    return item;
  }
  prependExecutorWithScreenshot(taskApply, appendAfterExecution = false) {
    const taskWithScreenshot = {
      ...taskApply,
      executor: async (param, context, ...args) => {
        const recorder = [];
        const { task } = context;
        task.recorder = recorder;
        const shot = await this.recordScreenshot(`before ${task.type}`);
        recorder.push(shot);
        const result = await taskApply.executor(param, context, ...args);
        if (taskApply.type === "Action") {
          await Promise.all([
            (async () => {
              await sleep(100);
              if (this.page.waitUntilNetworkIdle) {
                try {
                  await this.page.waitUntilNetworkIdle({
                    idleTime: 100,
                    timeout: 800
                  });
                } catch (error) {
                }
              }
            })(),
            sleep(200)
          ]);
        }
        if (appendAfterExecution) {
          const shot2 = await this.recordScreenshot("after Action");
          recorder.push(shot2);
        }
        return result;
      }
    };
    return taskWithScreenshot;
  }
  async convertPlanToExecutable(plans, cacheGroup) {
    const tasks = [];
    plans.forEach((plan2) => {
      if (plan2.type === "Locate") {
        if (plan2.locate === null || plan2.locate?.id === null || plan2.locate?.id === "null") {
          return;
        }
        const taskFind = {
          type: "Insight",
          subType: "Locate",
          param: plan2.locate || void 0,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, taskContext) => {
            const { task } = taskContext;
            assert3(
              param?.prompt || param?.id || param?.bbox,
              "No prompt or id or position or bbox to locate"
            );
            let insightDump;
            let usage;
            const dumpCollector = (dump) => {
              insightDump = dump;
              usage = dump?.taskInfo?.usage;
            };
            this.insight.onceDumpUpdatedFn = dumpCollector;
            const shotTime = Date.now();
            const pageContext = await this.insight.contextRetrieverFn("locate");
            const recordItem = {
              type: "screenshot",
              ts: shotTime,
              screenshot: pageContext.screenshotBase64,
              timing: "before locate"
            };
            const cachePrompt = `${param.prompt} @ ${param.searchArea || ""}`;
            const locateCache = cacheGroup?.matchCache(
              pageContext,
              "locate",
              cachePrompt
            );
            const idInCache = locateCache?.elements?.[0]?.id;
            let cacheHitFlag = false;
            let quickAnswerId = param?.id;
            if (!quickAnswerId && idInCache) {
              quickAnswerId = idInCache;
            }
            const quickAnswer = {
              id: quickAnswerId,
              bbox: param?.bbox
            };
            const startTime = Date.now();
            const element = await this.insight.locate(param, {
              quickAnswer
            });
            const aiCost = Date.now() - startTime;
            if (element && element.id === quickAnswerId) {
              cacheHitFlag = true;
            }
            if (element) {
              cacheGroup?.saveCache({
                type: "locate",
                pageContext: {
                  url: pageContext.url,
                  size: pageContext.size
                },
                prompt: cachePrompt,
                response: {
                  elements: [
                    {
                      id: element.id
                    }
                  ]
                }
              });
            }
            if (!element) {
              task.log = {
                dump: insightDump
              };
              throw new Error(`Element not found: ${param.prompt}`);
            }
            return {
              output: {
                element
              },
              pageContext,
              log: {
                dump: insightDump
              },
              cache: {
                hit: cacheHitFlag
              },
              recorder: [recordItem],
              aiCost,
              usage
            };
          }
        };
        tasks.push(taskFind);
      } else if (plan2.type === "Assert" || plan2.type === "AssertWithoutThrow") {
        const assertPlan = plan2;
        const taskAssert = {
          type: "Insight",
          subType: "Assert",
          param: assertPlan.param,
          thought: assertPlan.thought,
          locate: assertPlan.locate,
          executor: async (param, taskContext) => {
            const { task } = taskContext;
            let insightDump;
            const dumpCollector = (dump) => {
              insightDump = dump;
            };
            this.insight.onceDumpUpdatedFn = dumpCollector;
            const assertion = await this.insight.assert(
              assertPlan.param.assertion
            );
            if (!assertion.pass) {
              if (plan2.type === "Assert") {
                task.output = assertion;
                task.log = {
                  dump: insightDump
                };
                throw new Error(
                  assertion.thought || "Assertion failed without reason"
                );
              }
              task.error = assertion.thought;
            }
            return {
              output: assertion,
              log: {
                dump: insightDump
              },
              usage: assertion.usage
            };
          }
        };
        tasks.push(taskAssert);
      } else if (plan2.type === "Input") {
        const taskActionInput = {
          type: "Action",
          subType: "Input",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam, { element }) => {
            if (element) {
              await this.page.clearInput(element);
              if (!taskParam || !taskParam.value) {
                return;
              }
              await this.page.keyboard.type(taskParam.value);
            } else {
              await this.page.keyboard.type(taskParam.value);
            }
          }
        };
        tasks.push(taskActionInput);
      } else if (plan2.type === "KeyboardPress") {
        const taskActionKeyboardPress = {
          type: "Action",
          subType: "KeyboardPress",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            const keys = getKeyCommands(taskParam.value);
            await this.page.keyboard.press(keys);
          }
        };
        tasks.push(taskActionKeyboardPress);
      } else if (plan2.type === "Tap") {
        const taskActionTap = {
          type: "Action",
          subType: "Tap",
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, { element }) => {
            assert3(element, "Element not found, cannot tap");
            await this.page.mouse.click(element.center[0], element.center[1]);
          }
        };
        tasks.push(taskActionTap);
      } else if (plan2.type === "Drag") {
        const taskActionDrag = {
          type: "Action",
          subType: "Drag",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            assert3(
              taskParam?.start_box && taskParam?.end_box,
              "No start_box or end_box to drag"
            );
            await this.page.mouse.drag(taskParam.start_box, taskParam.end_box);
          }
        };
        tasks.push(taskActionDrag);
      } else if (plan2.type === "Hover") {
        const taskActionHover = {
          type: "Action",
          subType: "Hover",
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param, { element }) => {
            assert3(element, "Element not found, cannot hover");
            await this.page.mouse.move(element.center[0], element.center[1]);
          }
        };
        tasks.push(taskActionHover);
      } else if (plan2.type === "Scroll") {
        const taskActionScroll = {
          type: "Action",
          subType: "Scroll",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam, { element }) => {
            const startingPoint = element ? {
              left: element.center[0],
              top: element.center[1]
            } : void 0;
            const scrollToEventName = taskParam?.scrollType;
            if (scrollToEventName === "untilTop") {
              await this.page.scrollUntilTop(startingPoint);
            } else if (scrollToEventName === "untilBottom") {
              await this.page.scrollUntilBottom(startingPoint);
            } else if (scrollToEventName === "untilRight") {
              await this.page.scrollUntilRight(startingPoint);
            } else if (scrollToEventName === "untilLeft") {
              await this.page.scrollUntilLeft(startingPoint);
            } else if (scrollToEventName === "once" || !scrollToEventName) {
              if (taskParam?.direction === "down" || !taskParam || !taskParam.direction) {
                await this.page.scrollDown(
                  taskParam?.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "up") {
                await this.page.scrollUp(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "left") {
                await this.page.scrollLeft(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else if (taskParam.direction === "right") {
                await this.page.scrollRight(
                  taskParam.distance || void 0,
                  startingPoint
                );
              } else {
                throw new Error(
                  `Unknown scroll direction: ${taskParam.direction}`
                );
              }
              await sleep(500);
            } else {
              throw new Error(
                `Unknown scroll event type: ${scrollToEventName}, taskParam: ${JSON.stringify(
                  taskParam
                )}`
              );
            }
          }
        };
        tasks.push(taskActionScroll);
      } else if (plan2.type === "Sleep") {
        const taskActionSleep = {
          type: "Action",
          subType: "Sleep",
          param: plan2.param,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (taskParam) => {
            await sleep(taskParam?.timeMs || 3e3);
          }
        };
        tasks.push(taskActionSleep);
      } else if (plan2.type === "Error") {
        const taskActionError = {
          type: "Action",
          subType: "Error",
          param: plan2.param,
          thought: plan2.thought || plan2.param?.thought,
          locate: plan2.locate,
          executor: async () => {
            throw new Error(
              plan2?.thought || plan2.param?.thought || "error without thought"
            );
          }
        };
        tasks.push(taskActionError);
      } else if (plan2.type === "ExpectedFalsyCondition") {
        const taskActionFalsyConditionStatement = {
          type: "Action",
          subType: "ExpectedFalsyCondition",
          param: null,
          thought: plan2.param?.reason,
          locate: plan2.locate,
          executor: async () => {
          }
        };
        tasks.push(taskActionFalsyConditionStatement);
      } else if (plan2.type === "Finished") {
        const taskActionFinished = {
          type: "Action",
          subType: "Finished",
          param: null,
          thought: plan2.thought,
          locate: plan2.locate,
          executor: async (param) => {
          }
        };
        tasks.push(taskActionFinished);
      } else {
        throw new Error(`Unknown or unsupported task type: ${plan2.type}`);
      }
    });
    const wrappedTasks = tasks.map(
      (task, index) => {
        if (task.type === "Action") {
          return this.prependExecutorWithScreenshot(
            task,
            index === tasks.length - 1
          );
        }
        return task;
      }
    );
    return {
      tasks: wrappedTasks
    };
  }
  planningTaskFromPrompt(userInstruction, cacheGroup, log) {
    const task = {
      type: "Planning",
      locate: null,
      param: {
        userInstruction,
        log
      },
      executor: async (param, executorContext) => {
        const shotTime = Date.now();
        const pageContext = await this.insight.contextRetrieverFn("locate");
        const recordItem = {
          type: "screenshot",
          ts: shotTime,
          screenshot: pageContext.screenshotBase64,
          timing: "before planning"
        };
        executorContext.task.recorder = [recordItem];
        executorContext.task.pageContext = pageContext;
        const cachePrompt = `${param.userInstruction} @ ${param.log || ""}`;
        const planCache = cacheGroup.matchCache(
          pageContext,
          "plan",
          cachePrompt
        );
        let planResult;
        if (planCache) {
          if ("actions" in planCache && Array.isArray(planCache.actions)) {
            planCache.actions = planCache.actions.map((action) => {
              if (action.locate) {
                delete action.locate.bbox;
              }
              return action;
            });
          }
          planResult = planCache;
        } else {
          planResult = await plan(param.userInstruction, {
            context: pageContext,
            log: param.log
          });
        }
        const {
          actions,
          log: log2,
          more_actions_needed_by_instruction,
          error,
          usage,
          rawResponse,
          sleep: sleep3
        } = planResult;
        let stopCollecting = false;
        let bboxCollected = false;
        let planParsingError = "";
        const finalActions = (actions || []).reduce(
          (acc, planningAction) => {
            if (stopCollecting) {
              return acc;
            }
            if (planningAction.locate) {
              if (bboxCollected && planningAction.locate.bbox) {
                delete planningAction.locate.bbox;
              }
              if (planningAction.locate.bbox) {
                bboxCollected = true;
              }
              acc.push({
                type: "Locate",
                locate: planningAction.locate,
                param: null,
                thought: planningAction.locate.prompt
              });
            } else if (["Tap", "Hover", "Input"].includes(planningAction.type)) {
              planParsingError = `invalid planning response: ${JSON.stringify(planningAction)}`;
              stopCollecting = true;
              return acc;
            }
            acc.push(planningAction);
            return acc;
          },
          []
        );
        if (sleep3) {
          const timeNow = Date.now();
          const timeRemaining = sleep3 - (timeNow - shotTime);
          if (timeRemaining > 0) {
            finalActions.push({
              type: "Sleep",
              param: {
                timeMs: timeRemaining
              },
              locate: null
            });
          }
        }
        if (finalActions.length === 0) {
          assert3(
            !more_actions_needed_by_instruction || sleep3,
            error ? `Failed to plan: ${error}` : planParsingError || "No plan found"
          );
        }
        cacheGroup.saveCache({
          type: "plan",
          pageContext: {
            url: pageContext.url,
            size: pageContext.size
          },
          prompt: cachePrompt,
          response: planResult
        });
        return {
          output: {
            actions: finalActions,
            more_actions_needed_by_instruction,
            log: log2
          },
          cache: {
            hit: Boolean(planCache)
          },
          pageContext,
          recorder: [recordItem],
          usage,
          rawResponse
        };
      }
    };
    return task;
  }
  planningTaskToGoal(userInstruction, cacheGroup) {
    const task = {
      type: "Planning",
      locate: null,
      param: {
        userInstruction
      },
      executor: async (param, executorContext) => {
        const shotTime = Date.now();
        const pageContext = await this.insight.contextRetrieverFn("locate");
        const recordItem = {
          type: "screenshot",
          ts: shotTime,
          screenshot: pageContext.screenshotBase64,
          timing: "before planning"
        };
        executorContext.task.recorder = [recordItem];
        executorContext.task.pageContext = pageContext;
        this.appendConversationHistory({
          role: "user",
          content: [
            {
              type: "image_url",
              image_url: {
                url: pageContext.screenshotBase64
              }
            }
          ]
        });
        const startTime = Date.now();
        const planCache = cacheGroup.matchCache(
          pageContext,
          "ui-tars-plan",
          userInstruction
        );
        let planResult;
        if (planCache) {
          planResult = planCache;
        } else {
          planResult = await vlmPlanning({
            userInstruction: param.userInstruction,
            conversationHistory: this.conversationHistory,
            size: pageContext.size
          });
        }
        cacheGroup.saveCache({
          type: "ui-tars-plan",
          pageContext: {
            url: pageContext.url,
            size: pageContext.size
          },
          prompt: userInstruction,
          response: planResult
        });
        const aiCost = Date.now() - startTime;
        const { actions, action_summary } = planResult;
        this.appendConversationHistory({
          role: "assistant",
          content: action_summary
        });
        return {
          output: {
            actions,
            thought: actions[0]?.thought,
            actionType: actions[0].type,
            more_actions_needed_by_instruction: true,
            log: ""
          },
          cache: {
            hit: Boolean(planCache)
          },
          aiCost
        };
      }
    };
    return task;
  }
  async runPlans(title, plans, options) {
    const taskExecutor = new Executor(title, {
      onTaskStart: options?.onTaskStart
    });
    const { tasks } = await this.convertPlanToExecutable(plans);
    await taskExecutor.append(tasks);
    const result = await taskExecutor.flush();
    return {
      output: result,
      executor: taskExecutor
    };
  }
  async action(userPrompt, options) {
    const taskExecutor = new Executor(userPrompt, {
      onTaskStart: options?.onTaskStart
    });
    const cacheGroup = this.taskCache.getCacheGroupByPrompt(userPrompt);
    let planningTask = this.planningTaskFromPrompt(userPrompt, cacheGroup);
    let result;
    let replanCount = 0;
    const logLog = [];
    while (planningTask) {
      if (replanCount > replanningCountLimit) {
        const errorMsg = "Replanning too many times, please split the task into multiple steps";
        return this.appendErrorPlan(taskExecutor, errorMsg);
      }
      await taskExecutor.append(planningTask);
      const planResult = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: planResult,
          executor: taskExecutor
        };
      }
      const plans = planResult.actions || [];
      let executables;
      try {
        executables = await this.convertPlanToExecutable(plans, cacheGroup);
        taskExecutor.append(executables.tasks);
      } catch (error) {
        return this.appendErrorPlan(
          taskExecutor,
          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(
            plans
          )}`
        );
      }
      result = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: result,
          executor: taskExecutor
        };
      }
      if (planResult?.log) {
        logLog.push(planResult.log);
      }
      if (!planResult.more_actions_needed_by_instruction) {
        planningTask = null;
        break;
      }
      planningTask = this.planningTaskFromPrompt(
        userPrompt,
        cacheGroup,
        logLog.join("\n")
      );
      replanCount++;
    }
    return {
      output: result,
      executor: taskExecutor
    };
  }
  async actionToGoal(userPrompt, options) {
    const taskExecutor = new Executor(userPrompt, {
      onTaskStart: options?.onTaskStart
    });
    this.conversationHistory = [];
    const cacheGroup = this.taskCache.getCacheGroupByPrompt(userPrompt);
    const isCompleted = false;
    let currentActionNumber = 0;
    const maxActionNumber = 40;
    while (!isCompleted && currentActionNumber < maxActionNumber) {
      currentActionNumber++;
      const planningTask = this.planningTaskToGoal(
        userPrompt,
        cacheGroup
      );
      await taskExecutor.append(planningTask);
      const output = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output,
          executor: taskExecutor
        };
      }
      const plans = output.actions;
      let executables;
      try {
        executables = await this.convertPlanToExecutable(plans);
        taskExecutor.append(executables.tasks);
      } catch (error) {
        return this.appendErrorPlan(
          taskExecutor,
          `Error converting plans to executable tasks: ${error}, plans: ${JSON.stringify(
            plans
          )}`
        );
      }
      const result = await taskExecutor.flush();
      if (taskExecutor.isInErrorState()) {
        return {
          output: result,
          executor: taskExecutor
        };
      }
      if (plans[0].type === "Finished") {
        break;
      }
    }
    return {
      output: {},
      executor: taskExecutor
    };
  }
  async query(demand, options) {
    const description = typeof demand === "string" ? demand : JSON.stringify(demand);
    const taskExecutor = new Executor(description, {
      onTaskStart: options?.onTaskStart
    });
    const queryTask = {
      type: "Insight",
      subType: "Query",
      locate: null,
      param: {
        dataDemand: demand
      },
      executor: async (param) => {
        let insightDump;
        const dumpCollector = (dump) => {
          insightDump = dump;
        };
        this.insight.onceDumpUpdatedFn = dumpCollector;
        const { data, usage } = await this.insight.extract(
          param.dataDemand
        );
        return {
          output: data,
          log: { dump: insightDump },
          usage
        };
      }
    };
    await taskExecutor.append(this.prependExecutorWithScreenshot(queryTask));
    const output = await taskExecutor.flush();
    return {
      output,
      executor: taskExecutor
    };
  }
  async assert(assertion, options) {
    const description = `assert: ${assertion}`;
    const taskExecutor = new Executor(description, {
      onTaskStart: options?.onTaskStart
    });
    const assertionPlan = {
      type: "Assert",
      param: {
        assertion
      },
      locate: null
    };
    const { tasks } = await this.convertPlanToExecutable([assertionPlan]);
    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));
    const output = await taskExecutor.flush();
    return {
      output,
      executor: taskExecutor
    };
  }
  /**
   * Append a message to the conversation history
   * For user messages with images:
   * - Keep max 4 user image messages in history
   * - Remove oldest user image message when limit reached
   * For assistant messages:
   * - Simply append to history
   * @param conversationHistory Message to append
   */
  appendConversationHistory(conversationHistory) {
    if (conversationHistory.role === "user") {
      const userImgItems = this.conversationHistory.filter(
        (item) => item.role === "user"
      );
      if (userImgItems.length >= 4 && conversationHistory.role === "user") {
        const firstUserImgIndex = this.conversationHistory.findIndex(
          (item) => item.role === "user"
        );
        if (firstUserImgIndex >= 0) {
          this.conversationHistory.splice(firstUserImgIndex, 1);
        }
      }
    }
    this.conversationHistory.push(conversationHistory);
  }
  async appendErrorPlan(taskExecutor, errorMsg) {
    const errorPlan = {
      type: "Error",
      param: {
        thought: errorMsg
      },
      locate: null
    };
    const { tasks } = await this.convertPlanToExecutable([errorPlan]);
    await taskExecutor.append(this.prependExecutorWithScreenshot(tasks[0]));
    await taskExecutor.flush();
    return {
      output: void 0,
      executor: taskExecutor
    };
  }
  async waitFor(assertion, opt) {
    const description = `waitFor: ${assertion}`;
    const taskExecutor = new Executor(description, {
      onTaskStart: opt.onTaskStart
    });
    const { timeoutMs, checkIntervalMs } = opt;
    assert3(assertion, "No assertion for waitFor");
    assert3(timeoutMs, "No timeoutMs for waitFor");
    assert3(checkIntervalMs, "No checkIntervalMs for waitFor");
    const overallStartTime = Date.now();
    let startTime = Date.now();
    let errorThought = "";
    while (Date.now() - overallStartTime < timeoutMs) {
      startTime = Date.now();
      const assertPlan = {
        type: "AssertWithoutThrow",
        param: {
          assertion
        },
        locate: null
      };
      const { tasks: assertTasks } = await this.convertPlanToExecutable([
        assertPlan
      ]);
      await taskExecutor.append(
        this.prependExecutorWithScreenshot(assertTasks[0])
      );
      const output = await taskExecutor.flush();
      if (output?.pass) {
        return {
          output: void 0,
          executor: taskExecutor
        };
      }
      errorThought = output?.thought || `unknown error when waiting for assertion: ${assertion}`;
      const now = Date.now();
      if (now - startTime < checkIntervalMs) {
        const timeRemaining = checkIntervalMs - (now - startTime);
        const sleepPlan = {
          type: "Sleep",
          param: {
            timeMs: timeRemaining
          },
          locate: null
        };
        const { tasks: sleepTasks } = await this.convertPlanToExecutable([
          sleepPlan
        ]);
        await taskExecutor.append(
          this.prependExecutorWithScreenshot(sleepTasks[0])
        );
        await taskExecutor.flush();
      }
    }
    return this.appendErrorPlan(
      taskExecutor,
      `waitFor timeout: ${errorThought}`
    );
  }
};

// src/web-element.ts
var WebElementInfo = class {
  constructor({
    content,
    rect,
    // page,
    locator,
    id,
    attributes,
    indexId
  }) {
    this.content = content;
    this.rect = rect;
    this.center = [
      Math.floor(rect.left + rect.width / 2),
      Math.floor(rect.top + rect.height / 2)
    ];
    this.locator = locator;
    this.id = id;
    this.attributes = attributes;
    this.indexId = indexId;
  }
};

// src/common/plan-builder.ts
import { assert as assert4, getDebug as getDebug2 } from "@midscene/shared/utils";
var debug2 = getDebug2("plan-builder");
function buildPlans(type, locate, param) {
  let returnPlans = [];
  const locatePlan = locate ? {
    type: "Locate",
    locate,
    param: locate,
    thought: ""
  } : null;
  if (type === "Tap" || type === "Hover") {
    assert4(locatePlan, `missing locate info for action "${type}"`);
    const tapPlan = {
      type,
      param: null,
      thought: "",
      locate
    };
    returnPlans = [locatePlan, tapPlan];
  }
  if (type === "Input" || type === "KeyboardPress") {
    if (type === "Input") {
      assert4(locatePlan, `missing locate info for action "${type}"`);
    }
    assert4(param, `missing param for action "${type}"`);
    const inputPlan = {
      type,
      param,
      thought: "",
      locate
    };
    if (locatePlan) {
      returnPlans = [locatePlan, inputPlan];
    } else {
      returnPlans = [inputPlan];
    }
  }
  if (type === "Scroll") {
    assert4(param, `missing param for action "${type}"`);
    const scrollPlan = {
      type,
      param,
      thought: "",
      locate
    };
    if (locatePlan) {
      returnPlans = [locatePlan, scrollPlan];
    } else {
      returnPlans = [scrollPlan];
    }
  }
  if (type === "Sleep") {
    assert4(param, `missing param for action "${type}"`);
    const sleepPlan = {
      type,
      param,
      thought: "",
      locate: null
    };
    returnPlans = [sleepPlan];
  }
  if (returnPlans) {
    debug2("buildPlans", returnPlans);
    return returnPlans;
  }
  throw new Error(`Not supported type: ${type}`);
}

// src/common/utils.ts
import {
  MIDSCENE_REPORT_TAG_NAME,
  MIDSCENE_USE_VLM_UI_TARS,
  getAIConfig as getAIConfig2
} from "@midscene/core/env";
import { uploadTestInfoToServer } from "@midscene/core/utils";
import { NodeType } from "@midscene/shared/constants";
import { traverseTree, treeToList } from "@midscene/shared/extractor";
import { compositeElementInfoImg, resizeImgBase64 } from "@midscene/shared/img";
import { assert as assert5, uuid } from "@midscene/shared/utils";
import dayjs from "dayjs";
async function parseContextFromWebPage(page, _opt) {
  assert5(page, "page is required");
  if (page._forceUsePageContext) {
    return await page._forceUsePageContext();
  }
  const url = await page.url();
  uploadTestInfoToServer({ testUrl: url });
  let screenshotBase64;
  let tree;
  await Promise.all([
    page.screenshotBase64().then((base64) => {
      screenshotBase64 = base64;
    }),
    page.getElementsNodeTree().then(async (treeRoot) => {
      tree = treeRoot;
    })
  ]);
  const webTree = traverseTree(tree, (elementInfo) => {
    const { rect, id, content, attributes, locator, indexId } = elementInfo;
    return new WebElementInfo({
      rect,
      locator,
      id,
      content,
      attributes,
      indexId
    });
  });
  const elementsInfo = treeToList(webTree);
  assert5(screenshotBase64, "screenshotBase64 is required");
  const elementsPositionInfoWithoutText = elementsInfo.filter(
    (elementInfo) => {
      if (elementInfo.attributes.nodeType === NodeType.TEXT) {
        return false;
      }
      return true;
    }
  );
  const size = await page.size();
  if (size.dpr && size.dpr > 1) {
    screenshotBase64 = await resizeImgBase64(screenshotBase64, {
      width: size.width,
      height: size.height
    });
  }
  let screenshotBase64WithElementMarker = screenshotBase64;
  if (!getAIConfig2(MIDSCENE_USE_VLM_UI_TARS)) {
    if (_opt?.ignoreMarker) {
      screenshotBase64WithElementMarker = screenshotBase64;
    } else {
      screenshotBase64WithElementMarker = await compositeElementInfoImg({
        inputImgBase64: screenshotBase64,
        elementsPositionInfo: elementsPositionInfoWithoutText,
        size
      });
    }
  }
  return {
    content: elementsInfo,
    tree: webTree,
    size,
    screenshotBase64,
    screenshotBase64WithElementMarker,
    url
  };
}
function reportFileName(tag = "web") {
  const reportTagName = getAIConfig2(MIDSCENE_REPORT_TAG_NAME);
  const dateTimeInFileName = dayjs().format("YYYY-MM-DD_HH-mm-ss-SSS");
  return `${reportTagName || tag}-${dateTimeInFileName}`;
}
function printReportMsg(filepath) {
  console.log("Midscene - report file updated:", filepath);
}

// src/common/agent.ts
var PageAgent = class {
  constructor(page, opts) {
    /**
     * If true, the agent will not perform any actions
     */
    this.dryMode = false;
    this.page = page;
    this.opts = Object.assign(
      {
        generateReport: true,
        autoPrintReportMsg: true,
        groupName: "Midscene Report",
        groupDescription: ""
      },
      opts || {}
    );
    this.insight = new Insight(
      async (action) => {
        return this.getUIContext(action);
      },
      {
        generateElement: ({ content, rect }) => new WebElementInfo({
          content: content || "",
          rect,
          id: "",
          attributes: {
            nodeType: NodeType2.CONTAINER
          },
          indexId: 0
        })
      }
    );
    this.taskExecutor = new PageTaskExecutor(this.page, this.insight, {
      cacheId: opts?.cacheId
    });
    this.dump = this.resetDump();
    this.reportFileName = reportFileName(opts?.testId || "web");
  }
  async getUIContext(action) {
    if (action && (action === "extract" || action === "assert")) {
      return await parseContextFromWebPage(this.page, {
        ignoreMarker: true
      });
    }
    return await parseContextFromWebPage(this.page, {
      ignoreMarker: !!vlLocateMode()
    });
  }
  resetDump() {
    this.dump = {
      groupName: this.opts.groupName,
      groupDescription: this.opts.groupDescription,
      executions: []
    };
    return this.dump;
  }
  appendExecutionDump(execution) {
    const currentDump = this.dump;
    currentDump.executions.push(execution);
  }
  dumpDataString() {
    this.dump.groupName = this.opts.groupName;
    this.dump.groupDescription = this.opts.groupDescription;
    return stringifyDumpData2(this.dump);
  }
  reportHTMLString() {
    return reportHTMLContent(this.dumpDataString());
  }
  writeOutActionDumps() {
    const { generateReport, autoPrintReportMsg } = this.opts;
    this.reportFile = writeLogFile2({
      fileName: this.reportFileName,
      fileExt: groupedActionDumpFileExt,
      fileContent: this.dumpDataString(),
      type: "dump",
      generateReport
    });
    if (generateReport && autoPrintReportMsg && this.reportFile) {
      printReportMsg(this.reportFile);
    }
  }
  async callbackOnTaskStartTip(task) {
    if (this.opts.onTaskStartTip) {
      const param = paramStr(task);
      if (param) {
        const tip = `${typeStr(task)} - ${param}`;
        await this.opts.onTaskStartTip(tip);
      } else {
        await this.opts.onTaskStartTip(typeStr(task));
      }
    }
  }
  afterTaskRunning(executor, doNotThrowError = false) {
    this.appendExecutionDump(executor.dump());
    this.writeOutActionDumps();
    if (executor.isInErrorState() && !doNotThrowError) {
      const errorTask = executor.latestErrorTask();
      throw new Error(`${errorTask?.error}
${errorTask?.errorStack}`);
    }
  }
  async aiTap(targetPrompt, searchArea) {
    const plans = buildPlans("Tap", {
      prompt: targetPrompt,
      searchArea
    });
    const { executor, output } = await this.taskExecutor.runPlans(
      `Tap ${targetPrompt}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiHover(taskPrompt) {
    const plans = buildPlans("Hover", {
      prompt: taskPrompt
    });
    const { executor, output } = await this.taskExecutor.runPlans(
      `Hover ${taskPrompt}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiInput(where, value) {
    const plans = buildPlans(
      "Input",
      {
        prompt: where
      },
      {
        value
      }
    );
    const { executor, output } = await this.taskExecutor.runPlans(
      `Input ${where} - ${value}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  async aiKeyboardPress(where, value) {
    const plans = buildPlans(
      "KeyboardPress",
      {
        prompt: where
      },
      {
        value
      }
    );
    const { executor, output } = await this.taskExecutor.runPlans(
      `KeyboardPress ${where} - ${value}`,
      plans
    );
    this.afterTaskRunning(executor);
    return output;
  }
  // async aiScroll(where: string, param: PlanningActionParamScroll) {
  //   const plans = buildPlans(
  //     'Scroll',
  //     {
  //       prompt: where,
  //     },
  //     param,
  //   );
  //   const { executor, output } = await this.taskExecutor.runPlans(
  //     `Scroll ${where} - ${paramStr(param)}`,
  //     plans,
  //   );
  // }
  async aiAction(taskPrompt) {
    const { executor } = await (getAIConfig3(MIDSCENE_USE_VLM_UI_TARS2) ? this.taskExecutor.actionToGoal(taskPrompt, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    }) : this.taskExecutor.action(taskPrompt, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    }));
    this.afterTaskRunning(executor);
  }
  async aiQuery(demand) {
    const { output, executor } = await this.taskExecutor.query(demand, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.afterTaskRunning(executor);
    return output;
  }
  async aiAssert(assertion, msg, opt) {
    const { output, executor } = await this.taskExecutor.assert(assertion, {
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.afterTaskRunning(executor, true);
    if (output && opt?.keepRawResponse) {
      return output;
    }
    if (!output?.pass) {
      const errMsg = msg || `Assertion failed: ${assertion}`;
      const reasonMsg = `Reason: ${output?.thought || executor.latestErrorTask()?.error || "(no_reason)"}`;
      throw new Error(`${errMsg}
${reasonMsg}`);
    }
  }
  async aiWaitFor(assertion, opt) {
    const { executor } = await this.taskExecutor.waitFor(assertion, {
      timeoutMs: opt?.timeoutMs || 15 * 1e3,
      checkIntervalMs: opt?.checkIntervalMs || 3 * 1e3,
      assertion,
      onTaskStart: this.callbackOnTaskStartTip.bind(this)
    });
    this.appendExecutionDump(executor.dump());
    this.writeOutActionDumps();
    if (executor.isInErrorState()) {
      const errorTask = executor.latestErrorTask();
      throw new Error(`${errorTask?.error}
${errorTask?.errorStack}`);
    }
  }
  async ai(taskPrompt, type = "action") {
    if (type === "action") {
      return this.aiAction(taskPrompt);
    }
    if (type === "query") {
      return this.aiQuery(taskPrompt);
    }
    if (type === "assert") {
      return this.aiAssert(taskPrompt);
    }
    throw new Error(
      `Unknown type: ${type}, only support 'action', 'query', 'assert'`
    );
  }
  async runYaml(yamlScriptContent) {
    const script = parseYamlScript(yamlScriptContent, "yaml", true);
    const player = new ScriptPlayer(script, async (target) => {
      return { agent: this, freeFn: [] };
    });
    await player.run();
    if (player.status === "error") {
      const errors = player.taskStatusList.filter((task) => task.status === "error").map((task) => {
        return `task - ${task.name}: ${task.error?.message}`;
      }).join("\n");
      throw new Error(`Error(s) occurred in running yaml script:
${errors}`);
    }
    return {
      result: player.result
    };
  }
  async destroy() {
    await this.page.destroy();
  }
};

// src/puppeteer/base-page.ts
import { sleep as sleep2 } from "@midscene/core/utils";
import { treeToList as treeToList2 } from "@midscene/shared/extractor";
import { getExtraReturnLogic } from "@midscene/shared/fs";
import { assert as assert6, getDebug as getDebug3 } from "@midscene/shared/utils";
var debugPage = getDebug3("web:page");
var Page = class {
  constructor(underlyingPage, pageType) {
    this.everMoved = false;
    this.underlyingPage = underlyingPage;
    this.pageType = pageType;
  }
  async evaluate(pageFunction, arg) {
    let result;
    debugPage("evaluate function begin");
    if (this.pageType === "puppeteer") {
      result = await this.underlyingPage.evaluate(
        pageFunction,
        arg
      );
    } else {
      result = await this.underlyingPage.evaluate(
        pageFunction,
        arg
      );
    }
    debugPage("evaluate function end");
    return result;
  }
  async waitForNavigation() {
    if (this.pageType === "puppeteer" || this.pageType === "playwright") {
      debugPage("waitForNavigation begin");
      try {
        const maxWaitTime = 5e3;
        await this.underlyingPage.waitForSelector("html", {
          timeout: maxWaitTime
        });
      } catch (error) {
      }
      debugPage("waitForNavigation end");
    }
  }
  // @deprecated
  async getElementsInfo() {
    await this.waitForNavigation();
    debugPage("getElementsInfo begin");
    const tree = await this.getElementsNodeTree();
    debugPage("getElementsInfo end");
    return treeToList2(tree);
  }
  async getElementsNodeTree() {
    await this.waitForNavigation();
    const scripts = await getExtraReturnLogic(true);
    assert6(scripts, "scripts should be set before writing report in browser");
    const captureElementSnapshot = await this.evaluate(scripts);
    return captureElementSnapshot;
  }
  async size() {
    if (this.viewportSize)
      return this.viewportSize;
    const sizeInfo = await this.evaluate(() => {
      return {
        width: document.documentElement.clientWidth,
        height: document.documentElement.clientHeight,
        dpr: window.devicePixelRatio
      };
    });
    this.viewportSize = sizeInfo;
    return sizeInfo;
  }
  async screenshotBase64() {
    const imgType = "jpeg";
    const quality = 90;
    await this.waitForNavigation();
    debugPage("screenshotBase64 begin");
    let base64;
    if (this.pageType === "puppeteer") {
      const result = await this.underlyingPage.screenshot({
        type: imgType,
        quality,
        encoding: "base64"
      });
      base64 = `data:image/jpeg;base64,${result}`;
    } else if (this.pageType === "playwright") {
      const buffer = await this.underlyingPage.screenshot({
        type: imgType,
        quality
      });
      base64 = `data:image/jpeg;base64,${buffer.toString("base64")}`;
    } else {
      throw new Error("Unsupported page type for screenshot");
    }
    debugPage("screenshotBase64 end");
    return base64;
  }
  async url() {
    return this.underlyingPage.url();
  }
  get mouse() {
    return {
      click: async (x, y, options) => this.underlyingPage.mouse.click(x, y, {
        button: options?.button || "left",
        count: options?.count || 1
      }),
      wheel: async (deltaX, deltaY) => {
        if (this.pageType === "puppeteer") {
          await this.underlyingPage.mouse.wheel({
            deltaX,
            deltaY
          });
        } else if (this.pageType === "playwright") {
          await this.underlyingPage.mouse.wheel(
            deltaX,
            deltaY
          );
        }
      },
      move: async (x, y) => {
        this.everMoved = true;
        return this.underlyingPage.mouse.move(x, y);
      },
      drag: async (from, to) => {
        if (this.pageType === "puppeteer") {
          await this.underlyingPage.mouse.drag(
            {
              x: from.x,
              y: from.y
            },
            {
              x: to.x,
              y: to.y
            }
          );
        } else if (this.pageType === "playwright") {
          await this.underlyingPage.mouse.move(
            from.x,
            from.y
          );
          await this.underlyingPage.mouse.down();
          await this.underlyingPage.mouse.move(to.x, to.y);
          await this.underlyingPage.mouse.up();
        }
      }
    };
  }
  get keyboard() {
    return {
      type: async (text) => this.underlyingPage.keyboard.type(text, { delay: 80 }),
      press: async (action) => {
        const keys = Array.isArray(action) ? action : [action];
        for (const k of keys) {
          const commands = k.command ? [k.command] : [];
          await this.underlyingPage.keyboard.down(k.key, { commands });
        }
        for (const k of [...keys].reverse()) {
          await this.underlyingPage.keyboard.up(k.key);
        }
      },
      down: async (key) => {
        this.underlyingPage.keyboard.down(key);
      },
      up: async (key) => {
        this.underlyingPage.keyboard.up(key);
      }
    };
  }
  async clearInput(element) {
    if (!element) {
      console.warn("No element to clear input");
      return;
    }
    const isMac = process.platform === "darwin";
    if (isMac) {
      if (this.pageType === "puppeteer") {
        await this.mouse.click(element.center[0], element.center[1], {
          count: 3
        });
      } else {
        await this.mouse.click(element.center[0], element.center[1]);
        await this.underlyingPage.keyboard.down("Meta");
        await this.underlyingPage.keyboard.press("a");
        await this.underlyingPage.keyboard.up("Meta");
      }
    } else {
      await this.mouse.click(element.center[0], element.center[1]);
      await this.underlyingPage.keyboard.down("Control");
      await this.underlyingPage.keyboard.press("a");
      await this.underlyingPage.keyboard.up("Control");
    }
    await sleep2(100);
    await this.keyboard.press([{ key: "Backspace" }]);
  }
  async moveToPointBeforeScroll(point) {
    if (point) {
      await this.mouse.move(point.left, point.top);
    } else if (!this.everMoved) {
      const size = await this.size();
      const targetX = Math.floor(size.width / 2);
      const targetY = Math.floor(size.height / 2);
      await this.mouse.move(targetX, targetY);
    }
  }
  async scrollUntilTop(startingPoint) {
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(0, -9999999);
  }
  async scrollUntilBottom(startingPoint) {
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(0, 9999999);
  }
  async scrollUntilLeft(startingPoint) {
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(-9999999, 0);
  }
  async scrollUntilRight(startingPoint) {
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(9999999, 0);
  }
  async scrollUp(distance, startingPoint) {
    const innerHeight = await this.evaluate(() => window.innerHeight);
    const scrollDistance = distance || innerHeight * 0.7;
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(0, -scrollDistance);
  }
  async scrollDown(distance, startingPoint) {
    const innerHeight = await this.evaluate(() => window.innerHeight);
    const scrollDistance = distance || innerHeight * 0.7;
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(0, scrollDistance);
  }
  async scrollLeft(distance, startingPoint) {
    const innerWidth = await this.evaluate(() => window.innerWidth);
    const scrollDistance = distance || innerWidth * 0.7;
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(-scrollDistance, 0);
  }
  async scrollRight(distance, startingPoint) {
    const innerWidth = await this.evaluate(() => window.innerWidth);
    const scrollDistance = distance || innerWidth * 0.7;
    await this.moveToPointBeforeScroll(startingPoint);
    return this.mouse.wheel(scrollDistance, 0);
  }
  async destroy() {
  }
};

// src/puppeteer/page.ts
var WebPage = class extends Page {
  constructor(page) {
    super(page, "puppeteer");
  }
  async waitUntilNetworkIdle(options) {
    await this.underlyingPage.waitForNetworkIdle({
      idleTime: options?.idleTime || 300,
      concurrency: options?.concurrency || 2,
      timeout: options?.timeout || 15e3
    });
  }
};

// src/puppeteer/index.ts
import { overrideAIConfig } from "@midscene/core/env";

// src/puppeteer/agent-launcher.ts
import { readFileSync as readFileSync2 } from "fs";
import { assert as assert7, getDebug as getDebug4 } from "@midscene/shared/utils";
import puppeteer from "puppeteer";
var defaultUA = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36";
var defaultViewportWidth = 1440;
var defaultViewportHeight = 768;
var defaultViewportScale = process.platform === "darwin" ? 2 : 1;
var defaultWaitForNetworkIdleTimeout = 6 * 1e3;
var launcherDebug = getDebug4("puppeteer:launcher");
async function launchPuppeteerPage(target, preference) {
  assert7(target.url, "url is required");
  const freeFn = [];
  const ua = target.userAgent || defaultUA;
  let width = defaultViewportWidth;
  let preferMaximizedWindow = true;
  if (target.viewportWidth) {
    preferMaximizedWindow = false;
    assert7(
      typeof target.viewportWidth === "number",
      "viewportWidth must be a number"
    );
    width = Number.parseInt(target.viewportWidth, 10);
    assert7(width > 0, `viewportWidth must be greater than 0, but got ${width}`);
  }
  let height = defaultViewportHeight;
  if (target.viewportHeight) {
    preferMaximizedWindow = false;
    assert7(
      typeof target.viewportHeight === "number",
      "viewportHeight must be a number"
    );
    height = Number.parseInt(target.viewportHeight, 10);
    assert7(
      height > 0,
      `viewportHeight must be greater than 0, but got ${height}`
    );
  }
  let dpr = defaultViewportScale;
  if (target.viewportScale) {
    preferMaximizedWindow = false;
    assert7(
      typeof target.viewportScale === "number",
      "viewportScale must be a number"
    );
    dpr = Number.parseInt(target.viewportScale, 10);
    assert7(dpr > 0, `viewportScale must be greater than 0, but got ${dpr}`);
  }
  const viewportConfig = {
    width,
    height,
    deviceScaleFactor: dpr
  };
  const headed = preference?.headed || preference?.keepWindow;
  preferMaximizedWindow = preferMaximizedWindow && !!headed;
  if (headed && process.env.CI === "1") {
    console.warn(
      "you are probably running headed mode in CI, this will usually fail."
    );
  }
  const isWindows = process.platform === "win32";
  const args = [
    ...isWindows ? [] : ["--no-sandbox", "--disable-setuid-sandbox"],
    "--disable-features=PasswordLeakDetection",
    "--disable-save-password-bubble",
    `--user-agent="${ua}"`,
    preferMaximizedWindow ? "--start-maximized" : `--window-size=${width},${height + 200}`
    // add 200px for the address bar
  ];
  launcherDebug(
    "launching browser with viewport, headed: %s, viewport: %j, args: %j",
    headed,
    viewportConfig,
    args
  );
  const browser = await puppeteer.launch({
    headless: !headed,
    defaultViewport: viewportConfig,
    args
  });
  freeFn.push({
    name: "puppeteer_browser",
    fn: () => {
      if (!preference?.keepWindow) {
        if (isWindows) {
          setTimeout(() => {
            browser.close();
          }, 800);
        } else {
          browser.close();
        }
      }
    }
  });
  const pages = await browser.pages();
  const page = pages[0];
  if (target.cookie) {
    const cookieFileContent = readFileSync2(target.cookie, "utf-8");
    await page.setCookie(...JSON.parse(cookieFileContent));
  }
  const waitForNetworkIdleTimeout = typeof target.waitForNetworkIdle?.timeout === "number" ? target.waitForNetworkIdle.timeout : defaultWaitForNetworkIdleTimeout;
  try {
    await page.goto(target.url);
    if (waitForNetworkIdleTimeout > 0) {
      await page.waitForNetworkIdle({
        timeout: waitForNetworkIdleTimeout
      });
    }
  } catch (e) {
    if (typeof target.waitForNetworkIdle?.continueOnNetworkIdleError === "boolean" && !target.waitForNetworkIdle?.continueOnNetworkIdleError) {
      const newError = new Error(`failed to wait for network idle: ${e}`, {
        cause: e
      });
      throw newError;
    }
    const newMessage = `failed to wait for network idle after ${waitForNetworkIdleTimeout}ms, but the script will continue.`;
    console.warn(newMessage);
  }
  return { page, freeFn };
}
async function puppeteerAgentForTarget(target, preference) {
  const { page, freeFn } = await launchPuppeteerPage(target, preference);
  const agent = new PuppeteerAgent(page, {
    autoPrintReportMsg: false,
    testId: preference?.testId,
    cacheId: preference?.cacheId,
    forceSameTabNavigation: typeof target.forceSameTabNavigation !== "undefined" ? target.forceSameTabNavigation : true
    // true for default in yaml script
  });
  freeFn.push({
    name: "midscene_puppeteer_agent",
    fn: () => agent.destroy()
  });
  return { agent, freeFn };
}

// src/puppeteer/index.ts
var PuppeteerAgent = class extends PageAgent {
  constructor(page, opts) {
    const webPage = new WebPage(page);
    super(webPage, opts);
    const { forceSameTabNavigation = true } = opts ?? {};
    if (forceSameTabNavigation) {
      page.on("popup", async (popup) => {
        if (!popup) {
          console.warn(
            "got a popup event, but the popup is not ready yet, skip"
          );
          return;
        }
        const url = await popup.url();
        console.log(`Popup opened: ${url}`);
        await popup.close();
        await page.goto(url);
      });
    }
  }
};
export {
  PuppeteerAgent,
  WebPage as PuppeteerWebPage,
  overrideAIConfig,
  puppeteerAgentForTarget
};

//# sourceMappingURL=puppeteer.js.map