{"version":3,"mappings":"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","names":["assert","error"],"ignoreList":[],"sources":["../../src/bridge-mode/page-browser-side.ts","../../src/common/ui-utils.ts","../../src/chrome-extension/page.ts","../../src/chrome-extension/cdpInput.ts","../../src/chrome-extension/dynamic-scripts.ts","../../src/bridge-mode/common.ts","../../src/bridge-mode/io-client.ts"],"sourcesContent":["import type {\n  ChromePageDestroyOptions,\n  KeyboardAction,\n  MouseAction,\n} from '@/page';\nimport { assert } from '@midscene/shared/utils';\nimport ChromeExtensionProxyPage from '../chrome-extension/page';\nimport {\n  type BridgeConnectTabOptions,\n  BridgeEvent,\n  DefaultBridgeServerPort,\n  KeyboardEvent,\n  MouseEvent,\n} from './common';\nimport { BridgeClient } from './io-client';\n\ndeclare const __VERSION__: string;\n\nexport class ExtensionBridgePageBrowserSide extends ChromeExtensionProxyPage {\n  public bridgeClient: BridgeClient | null = null;\n\n  private destroyOptions?: ChromePageDestroyOptions;\n\n  private newlyCreatedTabIds: number[] = [];\n\n  constructor(\n    public onDisconnect: () => void = () => {},\n    public onLogMessage: (\n      message: string,\n      type: 'log' | 'status',\n    ) => void = () => {},\n    forceSameTabNavigation = true,\n  ) {\n    super(forceSameTabNavigation);\n  }\n\n  private async setupBridgeClient() {\n    this.bridgeClient = new BridgeClient(\n      `ws://localhost:${DefaultBridgeServerPort}`,\n      async (method, args: any[]) => {\n        console.log('bridge call from cli side', method, args);\n        if (method === BridgeEvent.ConnectNewTabWithUrl) {\n          return this.connectNewTabWithUrl.apply(\n            this,\n            args as unknown as [string],\n          );\n        }\n\n        if (method === BridgeEvent.ConnectCurrentTab) {\n          return this.connectCurrentTab.apply(this, args as any);\n        }\n\n        if (method === BridgeEvent.UpdateAgentStatus) {\n          return this.onLogMessage(args[0] as string, 'status');\n        }\n\n        const tabId = await this.getActiveTabId();\n        if (!tabId || tabId === 0) {\n          throw new Error('no tab is connected');\n        }\n\n        // this.onLogMessage(`calling method: ${method}`);\n\n        if (method.startsWith(MouseEvent.PREFIX)) {\n          const actionName = method.split('.')[1] as keyof MouseAction;\n          if (actionName === 'drag') {\n            return this.mouse[actionName].apply(this.mouse, args as any);\n          }\n          return this.mouse[actionName].apply(this.mouse, args as any);\n        }\n\n        if (method.startsWith(KeyboardEvent.PREFIX)) {\n          const actionName = method.split('.')[1] as keyof KeyboardAction;\n          if (actionName === 'press') {\n            return this.keyboard[actionName].apply(this.keyboard, args as any);\n          }\n          return this.keyboard[actionName].apply(this.keyboard, args as any);\n        }\n\n        try {\n          // @ts-expect-error\n          const result = await this[method as keyof ChromeExtensionProxyPage](\n            ...args,\n          );\n          return result;\n        } catch (e) {\n          const errorMessage = e instanceof Error ? e.message : 'Unknown error';\n          console.error('error calling method', method, args, e);\n          this.onLogMessage(\n            `Error calling method: ${method}, ${errorMessage}`,\n            'log',\n          );\n          throw new Error(errorMessage, { cause: e });\n        }\n      },\n      // on disconnect\n      () => {\n        return this.destroy();\n      },\n    );\n    await this.bridgeClient.connect();\n    this.onLogMessage(\n      `Bridge connected, cli-side version v${this.bridgeClient.serverVersion}, browser-side version v${__VERSION__}`,\n      'log',\n    );\n  }\n\n  public async connect() {\n    return await this.setupBridgeClient();\n  }\n\n  public async connectNewTabWithUrl(\n    url: string,\n    options: BridgeConnectTabOptions = {\n      forceSameTabNavigation: true,\n    },\n  ) {\n    const tab = await chrome.tabs.create({ url });\n    const tabId = tab.id;\n    assert(tabId, 'failed to get tabId after creating a new tab');\n\n    // new tab\n    this.onLogMessage(`Creating new tab: ${url}`, 'log');\n    this.newlyCreatedTabIds.push(tabId);\n\n    if (options?.forceSameTabNavigation) {\n      this.forceSameTabNavigation = true;\n    }\n\n    await this.setActiveTabId(tabId);\n  }\n\n  public async connectCurrentTab(\n    options: BridgeConnectTabOptions = {\n      forceSameTabNavigation: true,\n    },\n  ) {\n    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });\n    console.log('current tab', tabs);\n    const tabId = tabs[0]?.id;\n    assert(tabId, 'failed to get tabId');\n\n    this.onLogMessage(`Connected to current tab: ${tabs[0]?.url}`, 'log');\n\n    if (options?.forceSameTabNavigation) {\n      this.forceSameTabNavigation = true;\n    }\n\n    await this.setActiveTabId(tabId);\n  }\n\n  public async setDestroyOptions(options: ChromePageDestroyOptions) {\n    this.destroyOptions = options;\n  }\n\n  async destroy() {\n    if (this.destroyOptions?.closeTab && this.newlyCreatedTabIds.length > 0) {\n      this.onLogMessage('Closing all newly created tabs by bridge...', 'log');\n      for (const tabId of this.newlyCreatedTabIds) {\n        await chrome.tabs.remove(tabId);\n      }\n      this.newlyCreatedTabIds = [];\n    }\n\n    await super.destroy();\n\n    if (this.bridgeClient) {\n      this.bridgeClient.disconnect();\n      this.bridgeClient = null;\n      this.onDisconnect();\n    }\n  }\n}\n","import type {\n  ExecutionTask,\n  ExecutionTaskAction,\n  ExecutionTaskActionApply,\n  ExecutionTaskInsightAssertion,\n  ExecutionTaskInsightLocate,\n  ExecutionTaskInsightQuery,\n  ExecutionTaskPlanning,\n  PlanningActionParamScroll,\n} from '@midscene/core';\n\nexport function typeStr(task: ExecutionTask) {\n  return task.subType ? `${task.type} / ${task.subType || ''}` : task.type;\n}\n\nexport function getKeyCommands(\n  value: string | string[],\n): Array<{ key: string; command?: string }> {\n  // Ensure value is an array of keys\n  const keys = Array.isArray(value) ? value : [value];\n\n  // Process each key to attach a corresponding command if needed, based on the presence of 'Meta' or 'Control' in the keys array.\n  // ref: https://github.com/puppeteer/puppeteer/pull/9357/files#diff-32cf475237b000f980eb214a0a823e45a902bddb7d2426d677cae96397aa0ae4R94\n  return keys.reduce((acc: Array<{ key: string; command?: string }>, k) => {\n    const includeMeta = keys.includes('Meta') || keys.includes('Control');\n    if (includeMeta && (k === 'a' || k === 'A')) {\n      return acc.concat([{ key: k, command: 'SelectAll' }]);\n    }\n    if (includeMeta && (k === 'c' || k === 'C')) {\n      return acc.concat([{ key: k, command: 'Copy' }]);\n    }\n    if (includeMeta && (k === 'v' || k === 'V')) {\n      return acc.concat([{ key: k, command: 'Paste' }]);\n    }\n    return acc.concat([{ key: k }]);\n  }, []);\n}\n\nexport function paramStr(task: ExecutionTask) {\n  let value: string | undefined | object;\n  if (task.type === 'Planning') {\n    value = (task as ExecutionTaskPlanning)?.param?.userInstruction;\n  }\n\n  if (task.type === 'Insight') {\n    value =\n      (task as ExecutionTaskInsightLocate)?.param?.prompt ||\n      (task as ExecutionTaskInsightLocate)?.param?.id ||\n      (task as ExecutionTaskInsightQuery)?.param?.dataDemand ||\n      (task as ExecutionTaskInsightAssertion)?.param?.assertion;\n  }\n\n  if (task.type === 'Action') {\n    const sleepMs = (task as ExecutionTaskAction)?.param?.timeMs;\n    const scrollType = (\n      task as ExecutionTask<ExecutionTaskActionApply<PlanningActionParamScroll>>\n    )?.param?.scrollType;\n    if (sleepMs) {\n      value = `${sleepMs}ms`;\n    } else if (scrollType) {\n      const scrollDirection = (\n        task as ExecutionTask<\n          ExecutionTaskActionApply<PlanningActionParamScroll>\n        >\n      )?.param?.direction;\n      const scrollDistance = (\n        task as ExecutionTask<\n          ExecutionTaskActionApply<PlanningActionParamScroll>\n        >\n      )?.param?.distance;\n      value = `${scrollDirection || 'down'}, ${scrollType || 'once'}, ${\n        scrollDistance || 'distance-not-set'\n      }`;\n    } else {\n      value =\n        (task as ExecutionTaskAction)?.param?.value ||\n        (task as ExecutionTaskAction)?.param?.scrollType;\n    }\n\n    if (!value) {\n      value = task.thought;\n    }\n  }\n\n  if (typeof value === 'undefined') return '';\n  return typeof value === 'string'\n    ? value\n    : JSON.stringify(value, undefined, 2);\n}\n\nexport const limitOpenNewTabScript = `\nif (!window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__) {\n  window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__ = true;\n\n  // Intercept the window.open method (only once)\n  window.open = function(url) {\n    console.log('Blocked window.open:', url);\n    window.location.href = url;\n    return null;\n  };\n\n  // Block all a tag clicks with target=\"_blank\" (only once)\n  document.addEventListener('click', function(e) {\n    const target = e.target.closest('a');\n    if (target && target.target === '_blank') {\n      e.preventDefault();\n      console.log('Blocked new tab:', target.href);\n      window.location.href = target.href;\n      target.removeAttribute('target');\n    }\n  }, true);\n}\n`;\n","/// <reference types=\"chrome\" />\n\n/*\n  It is used to interact with the page tab from the chrome extension.\n  The page must be active when interacting with it.\n*/\n\nimport type { WebKeyInput } from '@/common/page';\nimport { limitOpenNewTabScript } from '@/common/ui-utils';\nimport type { AbstractPage, ChromePageDestroyOptions } from '@/page';\nimport type { ElementTreeNode, Point, Size } from '@midscene/core';\nimport type { ElementInfo } from '@midscene/shared/extractor';\nimport { treeToList } from '@midscene/shared/extractor';\nimport { assert } from '@midscene/shared/utils';\nimport type { Protocol as CDPTypes } from 'devtools-protocol';\nimport { CdpKeyboard } from './cdpInput';\nimport {\n  getHtmlElementScript,\n  injectStopWaterFlowAnimation,\n  injectWaterFlowAnimation,\n} from './dynamic-scripts';\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\ndeclare const __VERSION__: string;\n\nexport default class ChromeExtensionProxyPage implements AbstractPage {\n  pageType = 'chrome-extension-proxy';\n\n  public forceSameTabNavigation: boolean;\n  private version: string = __VERSION__;\n\n  private viewportSize?: Size;\n\n  private activeTabId: number | null = null;\n\n  private tabIdOfDebuggerAttached: number | null = null;\n\n  private attachingDebugger: Promise<void> | null = null;\n\n  private destroyed = false;\n\n  constructor(forceSameTabNavigation: boolean) {\n    this.forceSameTabNavigation = forceSameTabNavigation;\n  }\n\n  public async setActiveTabId(tabId: number) {\n    if (this.activeTabId) {\n      throw new Error(\n        `Active tab id is already set, which is ${this.activeTabId}, cannot set it to ${tabId}`,\n      );\n    }\n    this.activeTabId = tabId;\n  }\n\n  public async getActiveTabId() {\n    return this.activeTabId;\n  }\n\n  public async getTabIdOrConnectToCurrentTab() {\n    if (this.activeTabId) {\n      // alway keep on the connected tab\n      return this.activeTabId;\n    }\n    const tabId = await chrome.tabs\n      .query({ active: true, currentWindow: true })\n      .then((tabs) => tabs[0]?.id);\n    this.activeTabId = tabId || 0;\n    return this.activeTabId;\n  }\n\n  private async attachDebugger() {\n    assert(!this.destroyed, 'Page is destroyed');\n\n    // If already attaching, wait for it to complete\n    if (this.attachingDebugger) {\n      await this.attachingDebugger;\n      return;\n    }\n\n    // Create new attaching promise\n    this.attachingDebugger = (async () => {\n      const url = await this.url();\n      let error: Error | null = null;\n      if (url.startsWith('chrome://')) {\n        throw new Error(\n          'Cannot attach debugger to chrome:// pages, please use Midscene in a normal page with http://, https:// or file://',\n        );\n      }\n\n      try {\n        const currentTabId = await this.getTabIdOrConnectToCurrentTab();\n\n        if (this.tabIdOfDebuggerAttached === currentTabId) {\n          // already attached\n          return;\n        }\n        if (\n          this.tabIdOfDebuggerAttached &&\n          this.tabIdOfDebuggerAttached !== currentTabId\n        ) {\n          // detach the previous tab\n          console.log(\n            'detach the previous tab',\n            this.tabIdOfDebuggerAttached,\n            '->',\n            currentTabId,\n          );\n          try {\n            await this.detachDebugger(this.tabIdOfDebuggerAttached);\n          } catch (error) {\n            console.error('Failed to detach debugger', error);\n          }\n        }\n\n        // detach any debugger attached to the tab\n        console.log('attaching debugger', currentTabId);\n        await chrome.debugger.attach({ tabId: currentTabId }, '1.3');\n        // wait util the debugger banner in Chrome appears\n        await sleep(500);\n\n        this.tabIdOfDebuggerAttached = currentTabId;\n\n        await this.enableWaterFlowAnimation();\n      } catch (e) {\n        console.error('Failed to attach debugger', e);\n        error = e as Error;\n      } finally {\n        this.attachingDebugger = null;\n      }\n      if (error) {\n        throw error;\n      }\n    })();\n\n    await this.attachingDebugger;\n  }\n\n  private async showMousePointer(x: number, y: number) {\n    // update mouse pointer while redirecting\n    const pointerScript = `(() => {\n      if(typeof window.midsceneWaterFlowAnimation !== 'undefined') {\n        window.midsceneWaterFlowAnimation.enable();\n        window.midsceneWaterFlowAnimation.showMousePointer(${x}, ${y});\n      } else {\n        console.log('midsceneWaterFlowAnimation is not defined');\n      }\n    })()`;\n\n    await this.sendCommandToDebugger('Runtime.evaluate', {\n      expression: `${pointerScript}`,\n    });\n  }\n\n  private async hideMousePointer() {\n    await this.sendCommandToDebugger('Runtime.evaluate', {\n      expression: `(() => {\n        if(typeof window.midsceneWaterFlowAnimation !== 'undefined') {\n          window.midsceneWaterFlowAnimation.hideMousePointer();\n        }\n      })()`,\n    });\n  }\n\n  private async detachDebugger(tabId?: number) {\n    const tabIdToDetach = tabId || this.tabIdOfDebuggerAttached;\n    console.log('detaching debugger', tabIdToDetach);\n    if (!tabIdToDetach) {\n      console.warn('No tab id to detach');\n      return;\n    }\n\n    try {\n      await this.disableWaterFlowAnimation(tabIdToDetach);\n      await sleep(200); // wait for the animation to stop\n    } catch (error) {\n      console.warn('Failed to disable water flow animation', error);\n    }\n\n    try {\n      await chrome.debugger.detach({ tabId: tabIdToDetach });\n    } catch (error) {\n      // maybe tab is closed ?\n      console.warn('Failed to detach debugger', error);\n    }\n    this.tabIdOfDebuggerAttached = null;\n  }\n\n  private async enableWaterFlowAnimation() {\n    // limit open page in new tab\n    if (this.forceSameTabNavigation) {\n      await chrome.debugger.sendCommand(\n        { tabId: this.tabIdOfDebuggerAttached! },\n        'Runtime.evaluate',\n        {\n          expression: limitOpenNewTabScript,\n        },\n      );\n    }\n\n    const script = await injectWaterFlowAnimation();\n    // we will call this function in sendCommandToDebugger, so we have to use the chrome.debugger.sendCommand\n    await chrome.debugger.sendCommand(\n      { tabId: this.tabIdOfDebuggerAttached! },\n      'Runtime.evaluate',\n      {\n        expression: script,\n      },\n    );\n  }\n\n  private async disableWaterFlowAnimation(tabId: number) {\n    const script = await injectStopWaterFlowAnimation();\n\n    await chrome.debugger.sendCommand({ tabId }, 'Runtime.evaluate', {\n      expression: script,\n    });\n  }\n\n  private async sendCommandToDebugger<ResponseType = any, RequestType = any>(\n    command: string,\n    params: RequestType,\n  ): Promise<ResponseType> {\n    await this.attachDebugger();\n\n    assert(this.tabIdOfDebuggerAttached, 'Debugger is not attached');\n\n    // wo don't have to await it\n    this.enableWaterFlowAnimation();\n    return (await chrome.debugger.sendCommand(\n      { tabId: this.tabIdOfDebuggerAttached! },\n      command,\n      params as any,\n    )) as ResponseType;\n  }\n\n  private async getPageContentByCDP() {\n    const script = await getHtmlElementScript();\n\n    // check tab url\n    await this.sendCommandToDebugger<\n      CDPTypes.Runtime.EvaluateResponse,\n      CDPTypes.Runtime.EvaluateRequest\n    >('Runtime.evaluate', {\n      expression: script,\n    });\n\n    const expression = () => {\n      return {\n        tree: (window as any).midscene_element_inspector.webExtractNodeTree(),\n        size: {\n          width: document.documentElement.clientWidth,\n          height: document.documentElement.clientHeight,\n          dpr: window.devicePixelRatio,\n        },\n      };\n    };\n    const returnValue = await this.sendCommandToDebugger<\n      CDPTypes.Runtime.EvaluateResponse,\n      CDPTypes.Runtime.EvaluateRequest\n    >('Runtime.evaluate', {\n      expression: `(${expression.toString()})()`,\n      returnByValue: true,\n    });\n\n    if (!returnValue.result.value) {\n      const errorDescription =\n        returnValue.exceptionDetails?.exception?.description || '';\n      if (!errorDescription) {\n        console.error('returnValue from cdp', returnValue);\n      }\n      throw new Error(\n        `Failed to get page content from page, error: ${errorDescription}`,\n      );\n    }\n    // console.log('returnValue', returnValue.result.value);\n    return returnValue.result.value as {\n      tree: ElementTreeNode<ElementInfo>;\n      size: Size;\n    };\n  }\n\n  // current implementation is wait until domReadyState is complete\n  public async waitUntilNetworkIdle() {\n    const timeout = 10000;\n    const startTime = Date.now();\n    let lastReadyState = '';\n    while (Date.now() - startTime < timeout) {\n      const result = await this.sendCommandToDebugger('Runtime.evaluate', {\n        expression: 'document.readyState',\n      });\n      lastReadyState = result.result.value;\n      if (lastReadyState === 'complete') {\n        await new Promise((resolve) => setTimeout(resolve, 300));\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 300));\n    }\n    throw new Error(\n      `Failed to wait until network idle, last readyState: ${lastReadyState}`,\n    );\n  }\n\n  async getElementsInfo() {\n    const tree = await this.getElementsNodeTree();\n    return treeToList(tree);\n  }\n\n  async getElementsNodeTree() {\n    await this.hideMousePointer();\n    const content = await this.getPageContentByCDP();\n    if (content?.size) {\n      this.viewportSize = content.size;\n    }\n\n    return content?.tree || { node: null, children: [] };\n  }\n\n  async size() {\n    if (this.viewportSize) return this.viewportSize;\n    const content = await this.getPageContentByCDP();\n    return content.size;\n  }\n\n  async screenshotBase64() {\n    // screenshot by cdp\n    await this.hideMousePointer();\n    const base64 = await this.sendCommandToDebugger('Page.captureScreenshot', {\n      format: 'jpeg',\n      quality: 90,\n    });\n    return `data:image/jpeg;base64,${base64.data}`;\n  }\n\n  async url() {\n    const tabId = await this.getTabIdOrConnectToCurrentTab();\n    const url = await chrome.tabs.get(tabId).then((tab) => tab.url);\n    return url || '';\n  }\n\n  async scrollUntilTop(startingPoint?: Point) {\n    if (startingPoint) {\n      await this.mouse.move(startingPoint.left, startingPoint.top);\n    }\n    return this.mouse.wheel(0, -9999999);\n  }\n\n  async scrollUntilBottom(startingPoint?: Point) {\n    if (startingPoint) {\n      await this.mouse.move(startingPoint.left, startingPoint.top);\n    }\n    return this.mouse.wheel(0, 9999999);\n  }\n\n  async scrollUntilLeft(startingPoint?: Point) {\n    if (startingPoint) {\n      await this.mouse.move(startingPoint.left, startingPoint.top);\n    }\n    return this.mouse.wheel(-9999999, 0);\n  }\n\n  async scrollUntilRight(startingPoint?: Point) {\n    if (startingPoint) {\n      await this.mouse.move(startingPoint.left, startingPoint.top);\n    }\n    return this.mouse.wheel(9999999, 0);\n  }\n\n  async scrollUp(distance?: number, startingPoint?: Point) {\n    const { height } = await this.size();\n    const scrollDistance = distance || height * 0.7;\n    return this.mouse.wheel(\n      0,\n      -scrollDistance,\n      startingPoint?.left,\n      startingPoint?.top,\n    );\n  }\n\n  async scrollDown(distance?: number, startingPoint?: Point) {\n    const { height } = await this.size();\n    const scrollDistance = distance || height * 0.7;\n    return this.mouse.wheel(\n      0,\n      scrollDistance,\n      startingPoint?.left,\n      startingPoint?.top,\n    );\n  }\n\n  async scrollLeft(distance?: number, startingPoint?: Point) {\n    const { width } = await this.size();\n    const scrollDistance = distance || width * 0.7;\n    return this.mouse.wheel(\n      -scrollDistance,\n      0,\n      startingPoint?.left,\n      startingPoint?.top,\n    );\n  }\n\n  async scrollRight(distance?: number, startingPoint?: Point) {\n    const { width } = await this.size();\n    const scrollDistance = distance || width * 0.7;\n    return this.mouse.wheel(\n      scrollDistance,\n      0,\n      startingPoint?.left,\n      startingPoint?.top,\n    );\n  }\n\n  async clearInput(element: ElementInfo) {\n    if (!element) {\n      console.warn('No element to clear input');\n      return;\n    }\n\n    await this.mouse.click(element.center[0], element.center[1]);\n\n    await this.sendCommandToDebugger('Input.dispatchKeyEvent', {\n      type: 'keyDown',\n      commands: ['selectAll'],\n    });\n\n    await this.sendCommandToDebugger('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      commands: ['selectAll'],\n    });\n\n    await sleep(100);\n\n    await this.keyboard.press({\n      key: 'Backspace',\n    });\n  }\n\n  private latestMouseX = 100;\n  private latestMouseY = 100;\n\n  mouse = {\n    click: async (x: number, y: number) => {\n      await this.showMousePointer(x, y);\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        x,\n        y,\n        button: 'left',\n        clickCount: 1,\n      });\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        x,\n        y,\n        button: 'left',\n        clickCount: 1,\n      });\n    },\n    wheel: async (\n      deltaX: number,\n      deltaY: number,\n      startX?: number,\n      startY?: number,\n    ) => {\n      const finalX = startX || this.latestMouseX;\n      const finalY = startY || this.latestMouseY;\n      await this.showMousePointer(finalX, finalY);\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mouseWheel',\n        x: finalX,\n        y: finalY,\n        deltaX,\n        deltaY,\n      });\n      this.latestMouseX = finalX;\n      this.latestMouseY = finalY;\n    },\n    move: async (x: number, y: number) => {\n      await this.showMousePointer(x, y);\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mouseMoved',\n        x,\n        y,\n      });\n      this.latestMouseX = x;\n      this.latestMouseY = y;\n    },\n    drag: async (\n      from: { x: number; y: number },\n      to: { x: number; y: number },\n    ) => {\n      await this.mouse.move(from.x, from.y);\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        x: from.x,\n        y: from.y,\n        button: 'left',\n        clickCount: 1,\n      });\n      await this.mouse.move(to.x, to.y);\n      await this.sendCommandToDebugger('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        x: to.x,\n        y: to.y,\n        button: 'left',\n        clickCount: 1,\n      });\n    },\n  };\n\n  keyboard = {\n    type: async (text: string) => {\n      const cdpKeyboard = new CdpKeyboard({\n        send: this.sendCommandToDebugger.bind(this),\n      });\n      await cdpKeyboard.type(text, { delay: 0 });\n    },\n    press: async (\n      action:\n        | { key: WebKeyInput; command?: string }\n        | { key: WebKeyInput; command?: string }[],\n    ) => {\n      const cdpKeyboard = new CdpKeyboard({\n        send: this.sendCommandToDebugger.bind(this),\n      });\n      const keys = Array.isArray(action) ? action : [action];\n      for (const k of keys) {\n        const commands = k.command ? [k.command] : [];\n        await cdpKeyboard.down(k.key, { commands });\n      }\n      for (const k of [...keys].reverse()) {\n        await cdpKeyboard.up(k.key);\n      }\n    },\n  };\n\n  async destroy(): Promise<void> {\n    this.activeTabId = null;\n    await this.detachDebugger();\n    this.destroyed = true;\n  }\n}\n","// From https://github.com/puppeteer/puppeteer/blob/15abcc390862fd08cc3475532f2d9a11284aee6b/packages/puppeteer-core/src/cdp/Input.ts#L55\n// with some modifications to fit the session type\n/**\n * @license\n * Copyright 2017 Google Inc.\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  type KeyDefinition,\n  type KeyInput,\n  _keyDefinitions,\n} from '@midscene/shared/keyboard-layout';\nimport { assert } from '@midscene/shared/utils';\n\ntype KeyDescription = Required<\n  Pick<KeyDefinition, 'keyCode' | 'key' | 'text' | 'code' | 'location'>\n>;\n\n/**\n * @public\n */\nexport interface KeyDownOptions {\n  /**\n   * @deprecated Do not use. This is automatically handled.\n   */\n  text?: string;\n  /**\n   * @deprecated Do not use. This is automatically handled.\n   */\n  commands?: string[];\n}\n\n/**\n * @public\n */\nexport interface KeyboardTypeOptions {\n  delay?: number;\n}\n\n/**\n * @public\n */\nexport type KeyPressOptions = KeyDownOptions & KeyboardTypeOptions;\n\ntype InternalCDPSession = {\n  send: (command: string, params: any) => Promise<void>;\n};\n\n/**\n * @internal\n */\nexport class CdpKeyboard {\n  #pressedKeys = new Set<string>();\n\n  #client: InternalCDPSession;\n\n  _modifiers = 0;\n\n  constructor(client: InternalCDPSession) {\n    this.#client = client;\n  }\n\n  updateClient(client: InternalCDPSession): void {\n    this.#client = client;\n  }\n\n  async down(\n    key: KeyInput,\n    options: Readonly<KeyDownOptions> = {\n      text: undefined,\n      commands: [],\n    },\n  ): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    const autoRepeat = this.#pressedKeys.has(description.code);\n    this.#pressedKeys.add(description.code);\n    this._modifiers |= this.#modifierBit(description.key);\n\n    const text = options.text === undefined ? description.text : options.text;\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3,\n      commands: options.commands,\n    });\n  }\n\n  #modifierBit(key: string): number {\n    if (key === 'Alt') {\n      return 1;\n    }\n    if (key === 'Control') {\n      return 2;\n    }\n    if (key === 'Meta') {\n      return 4;\n    }\n    if (key === 'Shift') {\n      return 8;\n    }\n    return 0;\n  }\n\n  #keyDescriptionForString(keyString: KeyInput): KeyDescription {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0,\n    };\n\n    const definition = _keyDefinitions[keyString];\n\n    assert(definition, `Unknown key: \"${keyString}\"`);\n\n    if (definition.key) {\n      description.key = definition.key;\n    }\n    if (shift && definition.shiftKey) {\n      description.key = definition.shiftKey;\n    }\n\n    if (definition.keyCode) {\n      description.keyCode = definition.keyCode;\n    }\n    if (shift && definition.shiftKeyCode) {\n      description.keyCode = definition.shiftKeyCode;\n    }\n\n    if (definition.code) {\n      description.code = definition.code;\n    }\n\n    if (definition.location) {\n      description.location = definition.location;\n    }\n\n    if (description.key.length === 1) {\n      description.text = description.key;\n    }\n\n    if (definition.text) {\n      description.text = definition.text;\n    }\n    if (shift && definition.shiftText) {\n      description.text = definition.shiftText;\n    }\n\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8) {\n      description.text = '';\n    }\n\n    return description;\n  }\n\n  async up(key: KeyInput): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    this._modifiers &= ~this.#modifierBit(description.key);\n    this.#pressedKeys.delete(description.code);\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location,\n    });\n  }\n\n  async sendCharacter(char: string): Promise<void> {\n    await this.#client.send('Input.insertText', { text: char });\n  }\n\n  private charIsKey(char: string): char is KeyInput {\n    return !!_keyDefinitions[char as KeyInput];\n  }\n\n  async type(\n    text: string,\n    options: Readonly<KeyboardTypeOptions> = {},\n  ): Promise<void> {\n    const delay = options.delay || undefined;\n    for (const char of text) {\n      if (this.charIsKey(char)) {\n        await this.press(char, { delay });\n      } else {\n        if (delay) {\n          await new Promise((f) => {\n            return setTimeout(f, delay);\n          });\n        }\n        await this.sendCharacter(char);\n      }\n    }\n  }\n\n  async press(\n    key: KeyInput | KeyInput[],\n    options: Readonly<KeyPressOptions> = {},\n  ): Promise<void> {\n    const { delay = null } = options;\n    const keys = Array.isArray(key) ? key : [key];\n\n    for (const k of keys) {\n      await this.down(k, options);\n    }\n\n    if (delay) {\n      await new Promise((f) => {\n        return setTimeout(f, options.delay);\n      });\n    }\n\n    for (const k of [...keys].reverse()) {\n      await this.up(k);\n    }\n  }\n}\n","import fs from 'node:fs';\nimport { ifInBrowser } from '@midscene/shared/utils';\n\n// remember to include this file into extension's package\n// extract html element from page\nlet scriptFileContentCache: string | null = null;\nexport const getHtmlElementScript = async () => {\n  const scriptFileToRetrieve = chrome.runtime.getURL('scripts/htmlElement.js');\n  if (scriptFileContentCache) return scriptFileContentCache;\n  if (ifInBrowser) {\n    const script = await fetch(scriptFileToRetrieve);\n    scriptFileContentCache = await script.text();\n    return scriptFileContentCache;\n  }\n  return fs.readFileSync(scriptFileToRetrieve, 'utf8');\n};\n\n// inject water flow animation\nlet waterFlowScriptFileContentCache: string | null = null;\nexport const injectWaterFlowAnimation = async () => {\n  const waterFlowScriptFileToRetrieve = chrome.runtime.getURL(\n    'scripts/water-flow.js',\n  );\n  if (waterFlowScriptFileContentCache) return waterFlowScriptFileContentCache;\n  if (ifInBrowser) {\n    const script = await fetch(waterFlowScriptFileToRetrieve);\n    waterFlowScriptFileContentCache = await script.text();\n    return waterFlowScriptFileContentCache;\n  }\n  return fs.readFileSync(waterFlowScriptFileToRetrieve, 'utf8');\n};\n\n// inject stop water flow animation\nlet stopWaterFlowScriptFileContentCache: string | null = null;\nexport const injectStopWaterFlowAnimation = async () => {\n  const stopWaterFlowScriptFileToRetrieve = chrome.runtime.getURL(\n    'scripts/stop-water-flow.js',\n  );\n  if (stopWaterFlowScriptFileContentCache)\n    return stopWaterFlowScriptFileContentCache;\n  if (ifInBrowser) {\n    const script = await fetch(stopWaterFlowScriptFileToRetrieve);\n    stopWaterFlowScriptFileContentCache = await script.text();\n    return stopWaterFlowScriptFileContentCache;\n  }\n  return fs.readFileSync(stopWaterFlowScriptFileToRetrieve, 'utf8');\n};\n","export const DefaultBridgeServerPort = 3766;\nexport const DefaultLocalEndpoint = `http://127.0.0.1:${DefaultBridgeServerPort}`;\nexport const BridgeCallTimeout = 30000;\n\nexport enum BridgeEvent {\n  Call = 'bridge-call',\n  CallResponse = 'bridge-call-response',\n  UpdateAgentStatus = 'bridge-update-agent-status',\n  Message = 'bridge-message',\n  Connected = 'bridge-connected',\n  Refused = 'bridge-refused',\n  ConnectNewTabWithUrl = 'connectNewTabWithUrl',\n  ConnectCurrentTab = 'connectCurrentTab',\n  SetDestroyOptions = 'setDestroyOptions',\n}\n\nexport interface BridgeConnectTabOptions {\n  /**\n   * If true, the page will always track the active tab.\n   * @default true\n   */\n  forceSameTabNavigation?: boolean;\n}\n\nexport enum MouseEvent {\n  PREFIX = 'mouse.',\n  Click = 'mouse.click',\n  Wheel = 'mouse.wheel',\n  Move = 'mouse.move',\n  Drag = 'mouse.drag',\n}\n\nexport enum KeyboardEvent {\n  PREFIX = 'keyboard.',\n  Type = 'keyboard.type',\n  Press = 'keyboard.press',\n}\n\nexport const BridgePageType = 'page-over-chrome-extension-bridge';\n\nexport const BridgeErrorCodeNoClientConnected = 'no-client-connected';\n\nexport interface BridgeCall {\n  method: string;\n  args: any[];\n  response: any;\n  callTime: number;\n  responseTime: number;\n  callback: (error: Error | undefined, response: any) => void;\n  error?: Error;\n}\n\nexport interface BridgeCallRequest {\n  id: string;\n  method: string;\n  args: any[];\n}\n\nexport interface BridgeCallResponse {\n  id: string;\n  response: any;\n  error?: any;\n}\n\nexport interface BridgeConnectedEventPayload {\n  version: string;\n}\n","import { assert } from '@midscene/shared/utils';\nimport { io as ClientIO, type Socket as ClientSocket } from 'socket.io-client';\nimport {\n  type BridgeCallRequest,\n  type BridgeCallResponse,\n  type BridgeConnectedEventPayload,\n  BridgeEvent,\n} from './common';\n\ndeclare const __VERSION__: string;\n\n// ws client, this is where the request is processed\nexport class BridgeClient {\n  private socket: ClientSocket | null = null;\n  public serverVersion: string | null = null;\n  constructor(\n    public endpoint: string,\n    public onBridgeCall: (method: string, args: any[]) => Promise<any>,\n    public onDisconnect?: () => void,\n  ) {}\n\n  async connect() {\n    return new Promise((resolve, reject) => {\n      this.socket = ClientIO(this.endpoint, {\n        reconnection: false,\n        query: {\n          version: __VERSION__,\n        },\n      });\n\n      const timeout = setTimeout(() => {\n        try {\n          this.socket?.offAny();\n          this.socket?.close();\n        } catch (e) {\n          console.warn('got error when closing socket', e);\n        }\n        this.socket = null;\n        reject(new Error('failed to connect to bridge server after timeout'));\n      }, 1 * 1000);\n\n      // on disconnect\n      this.socket.on('disconnect', (reason: string) => {\n        // console.log('bridge-disconnected, reason:', reason);\n        this.socket = null;\n        this.onDisconnect?.();\n      });\n\n      this.socket.on(\n        BridgeEvent.Connected,\n        (payload: BridgeConnectedEventPayload) => {\n          clearTimeout(timeout);\n          // console.log('bridge-connected');\n          this.serverVersion = payload?.version || 'unknown';\n          resolve(this.socket);\n        },\n      );\n      this.socket.on(BridgeEvent.Refused, (e: any) => {\n        console.error('bridge-refused', e);\n        reject(new Error(e || 'bridge refused'));\n      });\n      this.socket.on(BridgeEvent.Call, (call: BridgeCallRequest) => {\n        const id = call.id;\n        assert(typeof id !== 'undefined', 'call id is required');\n        Promise.resolve().then(async () => {\n          let response: any;\n          try {\n            response = await this.onBridgeCall(call.method, call.args);\n          } catch (e: any) {\n            const errorContent = `Error from bridge client when calling, method: ${call.method}, args: ${call.args}, error: ${e?.message || e}\\n${e?.stack || ''}`;\n            console.error(errorContent);\n            return this.socket?.emit(BridgeEvent.CallResponse, {\n              id,\n              error: errorContent,\n            } as BridgeCallResponse);\n          }\n          this.socket?.emit(BridgeEvent.CallResponse, {\n            id,\n            response,\n          } as BridgeCallResponse);\n        });\n      });\n    });\n  }\n\n  disconnect() {\n    this.socket?.disconnect();\n    this.socket = null;\n  }\n}\n"]}