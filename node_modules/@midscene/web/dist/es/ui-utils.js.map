{"version":3,"mappings":";AAWO,SAAS,QAAQ,MAAqB;AAC3C,SAAO,KAAK,UAAU,GAAG,KAAK,IAAI,MAAM,KAAK,WAAW,EAAE,KAAK,KAAK;AACtE;AAEO,SAAS,eACd,OAC0C;AAE1C,QAAM,OAAO,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AAIlD,SAAO,KAAK,OAAO,CAAC,KAA+C,MAAM;AACvE,UAAM,cAAc,KAAK,SAAS,MAAM,KAAK,KAAK,SAAS,SAAS;AACpE,QAAI,gBAAgB,MAAM,OAAO,MAAM,MAAM;AAC3C,aAAO,IAAI,OAAO,CAAC,EAAE,KAAK,GAAG,SAAS,YAAY,CAAC,CAAC;AAAA,IACtD;AACA,QAAI,gBAAgB,MAAM,OAAO,MAAM,MAAM;AAC3C,aAAO,IAAI,OAAO,CAAC,EAAE,KAAK,GAAG,SAAS,OAAO,CAAC,CAAC;AAAA,IACjD;AACA,QAAI,gBAAgB,MAAM,OAAO,MAAM,MAAM;AAC3C,aAAO,IAAI,OAAO,CAAC,EAAE,KAAK,GAAG,SAAS,QAAQ,CAAC,CAAC;AAAA,IAClD;AACA,WAAO,IAAI,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;AAAA,EAChC,GAAG,CAAC,CAAC;AACP;AAEO,SAAS,SAAS,MAAqB;AAC5C,MAAI;AACJ,MAAI,KAAK,SAAS,YAAY;AAC5B,YAAS,MAAgC,OAAO;AAAA,EAClD;AAEA,MAAI,KAAK,SAAS,WAAW;AAC3B,YACG,MAAqC,OAAO,UAC5C,MAAqC,OAAO,MAC5C,MAAoC,OAAO,cAC3C,MAAwC,OAAO;AAAA,EACpD;AAEA,MAAI,KAAK,SAAS,UAAU;AAC1B,UAAM,UAAW,MAA8B,OAAO;AACtD,UAAM,aACJ,MACC,OAAO;AACV,QAAI,SAAS;AACX,cAAQ,GAAG,OAAO;AAAA,IACpB,WAAW,YAAY;AACrB,YAAM,kBACJ,MAGC,OAAO;AACV,YAAM,iBACJ,MAGC,OAAO;AACV,cAAQ,GAAG,mBAAmB,MAAM,KAAK,cAAc,MAAM,KAC3D,kBAAkB,kBACpB;AAAA,IACF,OAAO;AACL,cACG,MAA8B,OAAO,SACrC,MAA8B,OAAO;AAAA,IAC1C;AAEA,QAAI,CAAC,OAAO;AACV,cAAQ,KAAK;AAAA,IACf;AAAA,EACF;AAEA,MAAI,OAAO,UAAU;AAAa,WAAO;AACzC,SAAO,OAAO,UAAU,WACpB,QACA,KAAK,UAAU,OAAO,QAAW,CAAC;AACxC;AAEO,IAAM,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA","names":[],"ignoreList":[],"sources":["../../src/common/ui-utils.ts"],"sourcesContent":["import type {\n  ExecutionTask,\n  ExecutionTaskAction,\n  ExecutionTaskActionApply,\n  ExecutionTaskInsightAssertion,\n  ExecutionTaskInsightLocate,\n  ExecutionTaskInsightQuery,\n  ExecutionTaskPlanning,\n  PlanningActionParamScroll,\n} from '@midscene/core';\n\nexport function typeStr(task: ExecutionTask) {\n  return task.subType ? `${task.type} / ${task.subType || ''}` : task.type;\n}\n\nexport function getKeyCommands(\n  value: string | string[],\n): Array<{ key: string; command?: string }> {\n  // Ensure value is an array of keys\n  const keys = Array.isArray(value) ? value : [value];\n\n  // Process each key to attach a corresponding command if needed, based on the presence of 'Meta' or 'Control' in the keys array.\n  // ref: https://github.com/puppeteer/puppeteer/pull/9357/files#diff-32cf475237b000f980eb214a0a823e45a902bddb7d2426d677cae96397aa0ae4R94\n  return keys.reduce((acc: Array<{ key: string; command?: string }>, k) => {\n    const includeMeta = keys.includes('Meta') || keys.includes('Control');\n    if (includeMeta && (k === 'a' || k === 'A')) {\n      return acc.concat([{ key: k, command: 'SelectAll' }]);\n    }\n    if (includeMeta && (k === 'c' || k === 'C')) {\n      return acc.concat([{ key: k, command: 'Copy' }]);\n    }\n    if (includeMeta && (k === 'v' || k === 'V')) {\n      return acc.concat([{ key: k, command: 'Paste' }]);\n    }\n    return acc.concat([{ key: k }]);\n  }, []);\n}\n\nexport function paramStr(task: ExecutionTask) {\n  let value: string | undefined | object;\n  if (task.type === 'Planning') {\n    value = (task as ExecutionTaskPlanning)?.param?.userInstruction;\n  }\n\n  if (task.type === 'Insight') {\n    value =\n      (task as ExecutionTaskInsightLocate)?.param?.prompt ||\n      (task as ExecutionTaskInsightLocate)?.param?.id ||\n      (task as ExecutionTaskInsightQuery)?.param?.dataDemand ||\n      (task as ExecutionTaskInsightAssertion)?.param?.assertion;\n  }\n\n  if (task.type === 'Action') {\n    const sleepMs = (task as ExecutionTaskAction)?.param?.timeMs;\n    const scrollType = (\n      task as ExecutionTask<ExecutionTaskActionApply<PlanningActionParamScroll>>\n    )?.param?.scrollType;\n    if (sleepMs) {\n      value = `${sleepMs}ms`;\n    } else if (scrollType) {\n      const scrollDirection = (\n        task as ExecutionTask<\n          ExecutionTaskActionApply<PlanningActionParamScroll>\n        >\n      )?.param?.direction;\n      const scrollDistance = (\n        task as ExecutionTask<\n          ExecutionTaskActionApply<PlanningActionParamScroll>\n        >\n      )?.param?.distance;\n      value = `${scrollDirection || 'down'}, ${scrollType || 'once'}, ${\n        scrollDistance || 'distance-not-set'\n      }`;\n    } else {\n      value =\n        (task as ExecutionTaskAction)?.param?.value ||\n        (task as ExecutionTaskAction)?.param?.scrollType;\n    }\n\n    if (!value) {\n      value = task.thought;\n    }\n  }\n\n  if (typeof value === 'undefined') return '';\n  return typeof value === 'string'\n    ? value\n    : JSON.stringify(value, undefined, 2);\n}\n\nexport const limitOpenNewTabScript = `\nif (!window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__) {\n  window.__MIDSCENE_NEW_TAB_INTERCEPTOR_INITIALIZED__ = true;\n\n  // Intercept the window.open method (only once)\n  window.open = function(url) {\n    console.log('Blocked window.open:', url);\n    window.location.href = url;\n    return null;\n  };\n\n  // Block all a tag clicks with target=\"_blank\" (only once)\n  document.addEventListener('click', function(e) {\n    const target = e.target.closest('a');\n    if (target && target.target === '_blank') {\n      e.preventDefault();\n      console.log('Blocked new tab:', target.href);\n      window.location.href = target.href;\n      target.removeAttribute('target');\n    }\n  }, true);\n}\n`;\n"]}