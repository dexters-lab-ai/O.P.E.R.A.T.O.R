import { Page as Page$3 } from 'playwright';
import { BaseElement, Rect, UIContext, PlaywrightParserOpt, Size, Point, ElementTreeNode } from '@midscene/core';
import { ElementInfo, ElementNode } from '@midscene/shared/extractor';
import { KeyInput, Page as Page$2 } from 'puppeteer';
import { NodeType } from '@midscene/shared/constants';
import * as _midscene_core_dist_types_types_f45a4ee7 from '@midscene/core/dist/types/types-f45a4ee7';
import { Browser } from 'webdriverio';

declare class WebElementInfo implements BaseElement {
    content: string;
    locator?: string;
    rect: Rect;
    center: [number, number];
    id: string;
    indexId: number;
    attributes: {
        nodeType: NodeType;
        [key: string]: string;
    };
    constructor({ content, rect, locator, id, attributes, indexId, }: {
        content: string;
        rect: Rect;
        locator?: string;
        id: string;
        attributes: {
            nodeType: NodeType;
            [key: string]: string;
        };
        indexId: number;
    });
}

type WebUIContext = UIContext<WebElementInfo> & {
    url: string;
};
declare function parseContextFromWebPage(page: WebPage$1, _opt?: PlaywrightParserOpt): Promise<WebUIContext>;
declare function reportFileName(tag?: string): string;
declare function printReportMsg(filepath: string): void;
/**
 * Get the current execution file name
 * @returns The name of the current execution file
 */
declare function getCurrentExecutionFile(trace?: string): string | false;
declare function generateCacheId(fileName?: string): string;
declare const ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED = "NOT_IMPLEMENTED_AS_DESIGNED";

type MouseButton = 'left' | 'right' | 'middle';
interface MouseAction {
    click: (x: number, y: number, options: {
        button: MouseButton;
    }) => Promise<void>;
    wheel: (deltaX: number, deltaY: number) => Promise<void>;
    move: (x: number, y: number) => Promise<void>;
    drag: (from: {
        x: number;
        y: number;
    }, to: {
        x: number;
        y: number;
    }) => Promise<void>;
}
interface KeyboardAction {
    type: (text: string) => Promise<void>;
    press: (action: {
        key: WebKeyInput;
        command?: string;
    } | {
        key: WebKeyInput;
        command?: string;
    }[]) => Promise<void>;
}
interface ChromePageDestroyOptions {
    closeTab?: boolean;
}
declare abstract class AbstractPage {
    abstract pageType: string;
    abstract getElementsInfo(): Promise<ElementInfo[]>;
    abstract getElementsNodeTree(): Promise<ElementNode>;
    abstract url(): string | Promise<string>;
    abstract screenshotBase64?(): Promise<string>;
    abstract size(): Promise<Size>;
    get mouse(): MouseAction;
    get keyboard(): KeyboardAction;
    clearInput(element: ElementInfo): Promise<void>;
    abstract scrollUntilTop(startingPoint?: Point): Promise<void>;
    abstract scrollUntilBottom(startingPoint?: Point): Promise<void>;
    abstract scrollUntilLeft(startingPoint?: Point): Promise<void>;
    abstract scrollUntilRight(startingPoint?: Point): Promise<void>;
    abstract scrollUp(distance?: number, startingPoint?: Point): Promise<void>;
    abstract scrollDown(distance?: number, startingPoint?: Point): Promise<void>;
    abstract scrollLeft(distance?: number, startingPoint?: Point): Promise<void>;
    abstract scrollRight(distance?: number): Promise<void>;
    abstract _forceUsePageContext?(): Promise<WebUIContext>;
    abstract waitUntilNetworkIdle?(options?: {
        idleTime?: number;
        concurrency?: number;
    }): Promise<void>;
    abstract destroy(options?: ChromePageDestroyOptions): Promise<void>;
}

type WebKeyInput$1 = KeyInput;
declare class Page$1 implements AbstractPage {
    private browser;
    pageType: string;
    constructor(browser: Browser);
    getElementsInfo(): Promise<ElementInfo[]>;
    getElementsNodeTree(): Promise<any>;
    size(): Promise<Size>;
    screenshotBase64(): Promise<string>;
    get mouse(): {
        click: (x: number, y: number, options?: {
            button: MouseButton;
        }) => Promise<void>;
        wheel: (deltaX: number, deltaY: number) => Promise<void>;
        move: (x: number, y: number) => Promise<void>;
        drag: (from: {
            x: number;
            y: number;
        }, to: {
            x: number;
            y: number;
        }) => Promise<void>;
    };
    get keyboard(): {
        type: (text: string) => Promise<void>;
        press: (action: {
            key: WebKeyInput$1;
            command?: string;
        } | {
            key: WebKeyInput$1;
            command?: string;
        }[]) => Promise<void>;
    };
    clearInput(element: ElementInfo): Promise<void>;
    url(): string;
    scrollUntilTop(startingPoint?: Point): Promise<void>;
    scrollUntilBottom(startingPoint?: Point): Promise<void>;
    scrollUntilLeft(startingPoint?: Point): Promise<void>;
    scrollUntilRight(startingPoint?: Point): Promise<void>;
    scrollUp(distance?: number, startingPoint?: Point): Promise<void>;
    scrollDown(distance?: number, startingPoint?: Point): Promise<void>;
    scrollLeft(distance?: number, startingPoint?: Point): Promise<void>;
    scrollRight(distance?: number, startingPoint?: Point): Promise<void>;
    private keyboardType;
    private keyboardPress;
    private keyboardPressAction;
    private mouseClick;
    private mouseMove;
    private mouseDrag;
    private mouseWheel;
    destroy(): Promise<void>;
}

declare class ChromeExtensionProxyPage implements AbstractPage {
    pageType: string;
    forceSameTabNavigation: boolean;
    private version;
    private viewportSize?;
    private activeTabId;
    private tabIdOfDebuggerAttached;
    private attachingDebugger;
    private destroyed;
    constructor(forceSameTabNavigation: boolean);
    setActiveTabId(tabId: number): Promise<void>;
    getActiveTabId(): Promise<number | null>;
    getTabIdOrConnectToCurrentTab(): Promise<number>;
    private attachDebugger;
    private showMousePointer;
    private hideMousePointer;
    private detachDebugger;
    private enableWaterFlowAnimation;
    private disableWaterFlowAnimation;
    private sendCommandToDebugger;
    private getPageContentByCDP;
    waitUntilNetworkIdle(): Promise<void>;
    getElementsInfo(): Promise<ElementInfo[]>;
    getElementsNodeTree(): Promise<ElementTreeNode<ElementInfo>>;
    size(): Promise<Size>;
    screenshotBase64(): Promise<string>;
    url(): Promise<string>;
    scrollUntilTop(startingPoint?: Point): Promise<void>;
    scrollUntilBottom(startingPoint?: Point): Promise<void>;
    scrollUntilLeft(startingPoint?: Point): Promise<void>;
    scrollUntilRight(startingPoint?: Point): Promise<void>;
    scrollUp(distance?: number, startingPoint?: Point): Promise<void>;
    scrollDown(distance?: number, startingPoint?: Point): Promise<void>;
    scrollLeft(distance?: number, startingPoint?: Point): Promise<void>;
    scrollRight(distance?: number, startingPoint?: Point): Promise<void>;
    clearInput(element: ElementInfo): Promise<void>;
    private latestMouseX;
    private latestMouseY;
    mouse: {
        click: (x: number, y: number) => Promise<void>;
        wheel: (deltaX: number, deltaY: number, startX?: number, startY?: number) => Promise<void>;
        move: (x: number, y: number) => Promise<void>;
        drag: (from: {
            x: number;
            y: number;
        }, to: {
            x: number;
            y: number;
        }) => Promise<void>;
    };
    keyboard: {
        type: (text: string) => Promise<void>;
        press: (action: {
            key: WebKeyInput;
            command?: string;
        } | {
            key: WebKeyInput;
            command?: string;
        }[]) => Promise<void>;
    };
    destroy(): Promise<void>;
}

declare class StaticPage implements AbstractPage {
    pageType: string;
    private uiContext;
    constructor(uiContext: WebUIContext);
    getElementsInfo(): Promise<any>;
    getElementsNodeTree(): Promise<any>;
    size(): Promise<_midscene_core_dist_types_types_f45a4ee7.S>;
    screenshotBase64(): Promise<string>;
    url(): Promise<string>;
    scrollUntilTop(startingPoint?: Point): Promise<any>;
    scrollUntilBottom(startingPoint?: Point): Promise<any>;
    scrollUntilLeft(startingPoint?: Point): Promise<any>;
    scrollUntilRight(startingPoint?: Point): Promise<any>;
    scrollUp(distance?: number, startingPoint?: Point): Promise<any>;
    scrollDown(distance?: number, startingPoint?: Point): Promise<any>;
    scrollLeft(distance?: number, startingPoint?: Point): Promise<any>;
    scrollRight(distance?: number, startingPoint?: Point): Promise<any>;
    clearInput(): Promise<any>;
    mouse: {
        click: any;
        wheel: any;
        move: any;
        drag: any;
    };
    keyboard: {
        type: any;
        press: any;
    };
    _forceUsePageContext(): Promise<WebUIContext>;
    destroy(): Promise<void>;
}

declare class Page<AgentType extends 'puppeteer' | 'playwright', PageType extends Page$2 | Page$3> implements AbstractPage {
    protected underlyingPage: PageType;
    private viewportSize?;
    pageType: AgentType;
    private evaluate;
    constructor(underlyingPage: PageType, pageType: AgentType);
    waitForNavigation(): Promise<void>;
    getElementsInfo(): Promise<ElementInfo[]>;
    getElementsNodeTree(): Promise<ElementTreeNode<ElementInfo>>;
    size(): Promise<Size>;
    screenshotBase64(): Promise<string>;
    url(): Promise<string>;
    get mouse(): {
        click: (x: number, y: number, options?: {
            button?: MouseButton;
            count?: number;
        }) => Promise<void>;
        wheel: (deltaX: number, deltaY: number) => Promise<void>;
        move: (x: number, y: number) => Promise<void>;
        drag: (from: {
            x: number;
            y: number;
        }, to: {
            x: number;
            y: number;
        }) => Promise<void>;
    };
    get keyboard(): {
        type: (text: string) => Promise<void>;
        press: (action: {
            key: WebKeyInput;
            command?: string;
        } | {
            key: WebKeyInput;
            command?: string;
        }[]) => Promise<void>;
        down: (key: WebKeyInput) => Promise<void>;
        up: (key: WebKeyInput) => Promise<void>;
    };
    clearInput(element: ElementInfo): Promise<void>;
    private everMoved;
    private moveToPointBeforeScroll;
    scrollUntilTop(startingPoint?: Point): Promise<void>;
    scrollUntilBottom(startingPoint?: Point): Promise<void>;
    scrollUntilLeft(startingPoint?: Point): Promise<void>;
    scrollUntilRight(startingPoint?: Point): Promise<void>;
    scrollUp(distance?: number, startingPoint?: Point): Promise<void>;
    scrollDown(distance?: number, startingPoint?: Point): Promise<void>;
    scrollLeft(distance?: number, startingPoint?: Point): Promise<void>;
    scrollRight(distance?: number, startingPoint?: Point): Promise<void>;
    destroy(): Promise<void>;
}

declare class WebPage$2 extends Page<'puppeteer', Page$2> {
    constructor(page: Page$2);
    waitUntilNetworkIdle(options?: {
        idleTime?: number;
        concurrency?: number;
        timeout?: number;
    }): Promise<void>;
}

type WebPage$1 =
  | WebPage
  | WebPage$2
  | Page$1
  | StaticPage
  | ChromeExtensionProxyPage;
type WebKeyInput = KeyInput;

declare class WebPage extends Page<'playwright', Page$3> {
    constructor(page: Page$3);
}

export { ChromeExtensionProxyPage as C, ERROR_CODE_NOT_IMPLEMENTED_AS_DESIGNED as E, Page$1 as P, StaticPage as S, type WebPage$1 as W, WebPage$2 as a, WebPage as b, type ChromePageDestroyOptions as c, type WebUIContext as d, WebElementInfo as e, printReportMsg as f, getCurrentExecutionFile as g, generateCacheId as h, parseContextFromWebPage as p, reportFileName as r };
