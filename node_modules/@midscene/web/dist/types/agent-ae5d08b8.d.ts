import * as _midscene_core_dist_types_types_f45a4ee7 from '@midscene/core/dist/types/types-f45a4ee7';
import { d as WebUIContext, W as WebPage, e as WebElementInfo } from './page-b934ce61.js';
import { PlanningAIResponse, AIElementIdResponse, Insight, ExecutionTaskProgressOptions, Executor, InsightExtractParam, InsightAssertionResponse, PlanningActionParamWaitFor, OnTaskStartTip, GroupedActionDump, InsightAction, ExecutionDump, AgentAssertOpt, AgentWaitForOpt } from '@midscene/core';
import { vlmPlanning, ChatCompletionMessageParam } from '@midscene/core/ai-model';
import { getRunningPkgInfo } from '@midscene/shared/fs';

type PlanTask = {
    type: 'plan';
    prompt: string;
    pageContext: {
        url: string;
        size: {
            width: number;
            height: number;
        };
    };
    response: PlanningAIResponse;
};
type UITarsPlanTask = {
    type: 'ui-tars-plan';
    prompt: string;
    pageContext: {
        url: string;
        size: {
            width: number;
            height: number;
        };
    };
    response: Awaited<ReturnType<typeof vlmPlanning>>;
};
type LocateTask = {
    type: 'locate';
    prompt: string;
    pageContext: {
        url: string;
        size: {
            width: number;
            height: number;
        };
    };
    response: AIElementIdResponse;
};
type AiTasks = Array<PlanTask | LocateTask | UITarsPlanTask>;
type AiTaskCache = {
    aiTasks: Array<{
        prompt: string;
        tasks: AiTasks;
    }>;
};
type CacheGroup = {
    readCache: <T extends 'plan' | 'locate' | 'ui-tars-plan'>(pageContext: WebUIContext, type: T, actionPrompt: string) => T extends 'plan' ? PlanTask['response'] : T extends 'locate' ? LocateTask['response'] : UITarsPlanTask['response'];
    saveCache: (cache: UITarsPlanTask | PlanTask | LocateTask) => void;
};
declare class TaskCache {
    cache: AiTaskCache;
    cacheId: string;
    newCache: AiTaskCache;
    midscenePkgInfo: ReturnType<typeof getRunningPkgInfo> | null;
    constructor(opts?: {
        cacheId?: string;
    });
    getCacheGroupByPrompt(aiActionPrompt: string): CacheGroup;
    /**
     * Read and return cached responses asynchronously based on specific criteria
     * This function is mainly used to read cached responses from a certain storage medium.
     * It accepts three parameters: the page context information, the task type, and the user's prompt information.
     * In the function, it first checks whether there is cached data. If there is, it retrieves the first task response from the cache.
     * It then checks whether the task type is 'locate' and whether the corresponding element can be found in the new context.
     * If the element cannot be found, it returns false, indicating that the cache is invalid.
     * If the task type is correct and the user prompt matches, it checks whether the page context is the same.
     * If the page context is the same, it returns the cached response, indicating that the cache hit is successful.
     * If there is no cached data or the conditions are not met, the function returns false, indicating that no cache is available or the cache is not hit.
     *
     * @param pageContext UIContext<WebElementInfo> type, representing the context information of the current page
     * @param type String type, specifying the task type, can be 'plan' or 'locate'
     * @param userPrompt String type, representing user prompt information
     * @return Returns a Promise object that resolves to a boolean or object
     */
    readCache(pageContext: WebUIContext, type: 'plan', userPrompt: string, cacheGroup: AiTasks): PlanTask['response'];
    readCache(pageContext: WebUIContext, type: 'ui-tars-plan', userPrompt: string, cacheGroup: AiTasks): UITarsPlanTask['response'];
    readCache(pageContext: WebUIContext, type: 'locate', userPrompt: string, cacheGroup: AiTasks): LocateTask['response'];
    pageContextEqual(taskPageContext: LocateTask['pageContext'], pageContext: WebUIContext): boolean;
    /**
     * Generate task cache data.
     * This method is mainly used to create or obtain some cached data for tasks, and it returns a new cache object.
     * In the cache object, it may contain task-related information, states, or other necessary data.
     * It is assumed that the `newCache` property already exists in the current class or object and is a data structure used to store task cache.
     * @returns {Object} Returns a new cache object, which may include task cache data.
     */
    generateTaskCache(): AiTaskCache;
    readCacheFromFile(): AiTaskCache | undefined;
    writeCacheToFile(): void;
}

interface ExecutionResult<OutputType = any> {
    output: OutputType;
    executor: Executor;
}
declare class PageTaskExecutor {
    page: WebPage;
    insight: Insight<WebElementInfo, WebUIContext>;
    taskCache: TaskCache;
    conversationHistory: ChatCompletionMessageParam[];
    constructor(page: WebPage, insight: Insight<WebElementInfo, WebUIContext>, opts: {
        cacheId: string | undefined;
    });
    private recordScreenshot;
    private prependExecutorWithScreenshot;
    private convertPlanToExecutable;
    private planningTaskFromPrompt;
    private planningTaskToGoal;
    action(userPrompt: string, options?: ExecutionTaskProgressOptions): Promise<ExecutionResult>;
    actionToGoal(userPrompt: string, options?: ExecutionTaskProgressOptions): Promise<{
        output: any;
        executor: Executor;
    }>;
    query(demand: InsightExtractParam, options?: ExecutionTaskProgressOptions): Promise<ExecutionResult>;
    assert(assertion: string, options?: ExecutionTaskProgressOptions): Promise<ExecutionResult<InsightAssertionResponse>>;
    /**
     * Append a message to the conversation history
     * For user messages with images:
     * - Keep max 4 user image messages in history
     * - Remove oldest user image message when limit reached
     * For assistant messages:
     * - Simply append to history
     * @param conversationHistory Message to append
     */
    private appendConversationHistory;
    private appendErrorPlan;
    waitFor(assertion: string, opt: PlanningActionParamWaitFor): Promise<ExecutionResult<void>>;
}

interface PageAgentOpt {
    forceSameTabNavigation?: boolean;
    testId?: string;
    cacheId?: string;
    groupName?: string;
    groupDescription?: string;
    cache?: AiTaskCache;
    generateReport?: boolean;
    autoPrintReportMsg?: boolean;
    onTaskStartTip?: OnTaskStartTip;
}
declare class PageAgent<PageType extends WebPage = WebPage> {
    page: PageType;
    insight: Insight<WebElementInfo, WebUIContext>;
    dump: GroupedActionDump;
    reportFile?: string | null;
    reportFileName?: string;
    taskExecutor: PageTaskExecutor;
    opts: PageAgentOpt;
    /**
     * If true, the agent will not perform any actions
     */
    dryMode: boolean;
    constructor(page: PageType, opts?: PageAgentOpt);
    getUIContext(action?: InsightAction): Promise<WebUIContext>;
    resetDump(): GroupedActionDump;
    appendExecutionDump(execution: ExecutionDump): void;
    dumpDataString(): string;
    reportHTMLString(): string;
    writeOutActionDumps(): void;
    private callbackOnTaskStartTip;
    aiAction(taskPrompt: string): Promise<void>;
    aiQuery(demand: any): Promise<any>;
    aiAssert(assertion: string, msg?: string, opt?: AgentAssertOpt): Promise<_midscene_core_dist_types_types_f45a4ee7.f | undefined>;
    aiWaitFor(assertion: string, opt?: AgentWaitForOpt): Promise<void>;
    ai(taskPrompt: string, type?: string): Promise<any>;
    runYaml(yamlScriptContent: string): Promise<{
        result: Record<string, any>;
    }>;
    destroy(): Promise<void>;
}

export { PageAgent as P, type PageAgentOpt as a, PageTaskExecutor as b };
