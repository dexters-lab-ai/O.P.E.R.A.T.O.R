import { NodeType } from '@midscene/shared/constants';
import { ChatCompletionMessageParam } from 'openai/resources';

interface Point {
    left: number;
    top: number;
}
interface Size {
    width: number;
    height: number;
    dpr?: number;
}
type Rect = Point & Size & {
    zoom?: number;
};
declare abstract class BaseElement {
    abstract id: string;
    abstract indexId?: number;
    abstract attributes: {
        nodeType: NodeType;
        [key: string]: string;
    };
    abstract content: string;
    abstract rect: Rect;
    abstract center: [number, number];
    abstract locator?: string;
}
interface ElementTreeNode<ElementType extends BaseElement = BaseElement> {
    node: ElementType | null;
    children: ElementTreeNode<ElementType>[];
}
type AIUsageInfo = Record<string, any> & {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
};
/**
 * openai
 *
 */
declare enum AIResponseFormat {
    JSON = "json_object",
    TEXT = "text"
}
type AISingleElementResponseById = {
    id: string;
    reason?: string;
    text?: string;
};
type AISingleElementResponseByPosition = {
    position?: {
        x: number;
        y: number;
    };
    bbox?: [number, number, number, number];
    reason: string;
    text: string;
};
type AISingleElementResponse = AISingleElementResponseById;
interface AIElementLocatorResponse {
    elements: {
        id: string;
        reason?: string;
        text?: string;
    }[];
    bbox?: [number, number, number, number];
    errors?: string[];
}
interface AIElementCoordinatesResponse {
    bbox: [number, number, number, number];
    errors?: string[];
}
type AIElementResponse = AIElementLocatorResponse | AIElementCoordinatesResponse;
interface AISectionParseResponse<DataShape> {
    data: DataShape;
    sections?: LiteUISection[];
    errors?: string[];
}
interface AISectionLocatorResponse {
    bbox: [number, number, number, number];
    error?: string;
}
interface AIAssertionResponse {
    pass: boolean;
    thought: string;
}
/**
 * context
 */
declare abstract class UIContext<ElementType extends BaseElement = BaseElement> {
    abstract screenshotBase64: string;
    abstract screenshotBase64WithElementMarker?: string;
    abstract content: ElementType[];
    abstract tree: ElementTreeNode<ElementType>;
    abstract size: Size;
}
/**
 * insight
 */
type CallAIFn = <T>(messages: ChatCompletionMessageParam[]) => Promise<T>;
interface InsightOptions {
    taskInfo?: Omit<InsightTaskInfo, 'durationMs'>;
    aiVendorFn?: CallAIFn;
    generateElement?: (opts: {
        content?: string;
        rect: BaseElement['rect'];
    }) => BaseElement;
}
type EnsureObject<T> = {
    [K in keyof T]: any;
};
type InsightAction = 'locate' | 'extract' | 'assert';
type InsightExtractParam = string | Record<string, string>;
interface InsightTaskInfo {
    durationMs: number;
    formatResponse?: string;
    rawResponse?: string;
    usage?: AIUsageInfo;
}
interface DumpMeta {
    sdkVersion: string;
    logTime: number;
    model_name: string;
    model_description?: string;
}
interface ReportDumpWithAttributes {
    dumpString: string;
    attributes?: Record<string, any>;
}
interface InsightDump extends DumpMeta {
    type: 'locate' | 'extract' | 'assert';
    logId: string;
    context: UIContext;
    userQuery: {
        element?: string;
        dataDemand?: InsightExtractParam;
        sections?: Record<string, string>;
        assertion?: string;
    };
    quickAnswer?: Partial<AISingleElementResponse> | null;
    matchedSection: [];
    matchedElement: BaseElement[];
    data: any;
    assertionPass?: boolean;
    assertionThought?: string;
    taskInfo: InsightTaskInfo;
    error?: string;
}
type PartialInsightDumpFromSDK = Omit<InsightDump, 'sdkVersion' | 'logTime' | 'logId' | 'model_name'>;
type DumpSubscriber = (dump: InsightDump) => Promise<void> | void;
interface LiteUISection {
    name: string;
    description: string;
    sectionCharacteristics: string;
    textIds: string[];
}
type ElementById = (id: string) => BaseElement | null;
type InsightAssertionResponse = AIAssertionResponse & {
    usage?: AIUsageInfo;
};
/**
 * agent
 */
type OnTaskStartTip = (tip: string) => Promise<void> | void;
interface AgentWaitForOpt {
    checkIntervalMs?: number;
    timeoutMs?: number;
}
interface AgentAssertOpt {
    keepRawResponse?: boolean;
}
/**
 * planning
 *
 */
interface PlanningLocateParam {
    id?: string;
    bbox?: [number, number, number, number];
    prompt: string;
    searchArea?: string;
}
interface PlanningAction<ParamType = any> {
    thought?: string;
    type: 'Locate' | 'Tap' | 'Drag' | 'Hover' | 'Input' | 'KeyboardPress' | 'Scroll' | 'Error' | 'ExpectedFalsyCondition' | 'Assert' | 'AssertWithoutThrow' | 'Sleep' | 'Finished';
    param: ParamType;
    locate: PlanningLocateParam | null;
}
interface PlanningAIResponse {
    action?: PlanningAction;
    actions?: PlanningAction[];
    more_actions_needed_by_instruction: boolean;
    log: string;
    sleep?: number;
    error?: string;
    usage?: AIUsageInfo;
    rawResponse?: string;
}
type PlanningActionParamTap = null;
type PlanningActionParamHover = null;
interface PlanningActionParamInputOrKeyPress {
    value: string;
}
interface PlanningActionParamScroll {
    direction: 'down' | 'up' | 'right' | 'left';
    scrollType: 'once' | 'untilBottom' | 'untilTop' | 'untilRight' | 'untilLeft';
    distance: null | number;
}
interface PlanningActionParamAssert {
    assertion: string;
}
interface PlanningActionParamSleep {
    timeMs: number;
}
interface PlanningActionParamError {
    thought: string;
}
type PlanningActionParamWaitFor = ExecutionTaskProgressOptions & AgentWaitForOpt & {
    assertion: string;
};
/**
 * misc
 */
interface Color {
    name: string;
    hex: string;
}
interface BaseAgentParserOpt {
    selector?: string;
    ignoreMarker?: boolean;
}
interface PuppeteerParserOpt extends BaseAgentParserOpt {
}
interface PlaywrightParserOpt extends BaseAgentParserOpt {
}
interface ExecutionTaskProgressOptions {
    onTaskStart?: (task: ExecutionTask) => Promise<void> | void;
}
interface ExecutionRecorderItem {
    type: 'screenshot';
    ts: number;
    screenshot?: string;
    timing?: string;
}
type ExecutionTaskType = 'Planning' | 'Insight' | 'Action' | 'Assertion';
interface ExecutorContext {
    task: ExecutionTask;
    element?: BaseElement | null;
}
interface TaskCacheInfo {
    hit: boolean;
}
interface ExecutionTaskApply<Type extends ExecutionTaskType = any, TaskParam = any, TaskOutput = any, TaskLog = any> {
    type: Type;
    subType?: string;
    param?: TaskParam;
    thought?: string;
    locate: PlanningLocateParam | null;
    quickAnswer?: AISingleElementResponse | null;
    pageContext?: UIContext;
    executor: (param: TaskParam, context: ExecutorContext) => Promise<ExecutionTaskReturn<TaskOutput, TaskLog> | undefined | void> | undefined | void;
}
interface ExecutionTaskReturn<TaskOutput = unknown, TaskLog = unknown> {
    output?: TaskOutput;
    log?: TaskLog;
    recorder?: ExecutionRecorderItem[];
    cache?: TaskCacheInfo;
}
type ExecutionTask<E extends ExecutionTaskApply<any, any, any> = ExecutionTaskApply<any, any, any>> = E & ExecutionTaskReturn<E extends ExecutionTaskApply<any, any, infer TaskOutput, any> ? TaskOutput : unknown, E extends ExecutionTaskApply<any, any, any, infer TaskLog> ? TaskLog : unknown> & {
    status: 'pending' | 'running' | 'finished' | 'failed' | 'cancelled';
    error?: string;
    errorStack?: string;
    timing?: {
        start: number;
        end?: number;
        cost?: number;
        aiCost?: number;
    };
    usage?: AIUsageInfo;
};
interface ExecutionDump extends DumpMeta {
    name: string;
    description?: string;
    tasks: ExecutionTask[];
}
type ExecutionTaskInsightLocateParam = PlanningLocateParam;
interface ExecutionTaskInsightLocateOutput {
    element: BaseElement | null;
}
interface ExecutionTaskInsightDumpLog {
    dump?: InsightDump;
}
type ExecutionTaskInsightLocateApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightLocateParam, ExecutionTaskInsightLocateOutput, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightLocate = ExecutionTask<ExecutionTaskInsightLocateApply>;
interface ExecutionTaskInsightQueryParam {
    dataDemand: InsightExtractParam;
}
interface ExecutionTaskInsightQueryOutput {
    data: any;
}
type ExecutionTaskInsightQueryApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightQueryParam, any, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightQuery = ExecutionTask<ExecutionTaskInsightQueryApply>;
interface ExecutionTaskInsightAssertionParam {
    assertion: string;
}
type ExecutionTaskInsightAssertionApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightAssertionParam, InsightAssertionResponse, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightAssertion = ExecutionTask<ExecutionTaskInsightAssertionApply>;
type ExecutionTaskActionApply<ActionParam = any> = ExecutionTaskApply<'Action', ActionParam, void, void>;
type ExecutionTaskAction = ExecutionTask<ExecutionTaskActionApply>;
type ExecutionTaskPlanningApply = ExecutionTaskApply<'Planning', {
    userInstruction: string;
    log?: string;
}, PlanningAIResponse>;
type ExecutionTaskPlanning = ExecutionTask<ExecutionTaskPlanningApply>;
interface GroupedActionDump {
    groupName: string;
    groupDescription?: string;
    executions: ExecutionDump[];
}

export { type ExecutionRecorderItem as $, type AISingleElementResponse as A, BaseElement as B, type CallAIFn as C, type DumpSubscriber as D, type ExecutionTask as E, type AgentAssertOpt as F, type PlanningAction as G, type PlanningAIResponse as H, type InsightAction as I, type PlanningActionParamTap as J, type PlanningActionParamHover as K, type LiteUISection as L, type PlanningActionParamInputOrKeyPress as M, type PlanningActionParamScroll as N, type OnTaskStartTip as O, type PlanningLocateParam as P, type PlanningActionParamAssert as Q, type Rect as R, type Size as S, type PlanningActionParamSleep as T, UIContext as U, type PlanningActionParamError as V, type PlanningActionParamWaitFor as W, type Color as X, type BaseAgentParserOpt as Y, type PuppeteerParserOpt as Z, type PlaywrightParserOpt as _, type ExecutionTaskProgressOptions as a, type ExecutionTaskType as a0, type ExecutorContext as a1, type TaskCacheInfo as a2, type ExecutionTaskReturn as a3, type ExecutionTaskInsightLocateParam as a4, type ExecutionTaskInsightLocateOutput as a5, type ExecutionTaskInsightDumpLog as a6, type ExecutionTaskInsightLocateApply as a7, type ExecutionTaskInsightLocate as a8, type ExecutionTaskInsightQueryParam as a9, type ExecutionTaskInsightQueryOutput as aa, type ExecutionTaskInsightQueryApply as ab, type ExecutionTaskInsightQuery as ac, type ExecutionTaskInsightAssertionParam as ad, type ExecutionTaskInsightAssertionApply as ae, type ExecutionTaskInsightAssertion as af, type ExecutionTaskActionApply as ag, type ExecutionTaskAction as ah, type ExecutionTaskPlanningApply as ai, type ExecutionTaskPlanning as aj, type GroupedActionDump as ak, type ExecutionTaskApply as b, type ExecutionDump as c, type InsightOptions as d, type InsightTaskInfo as e, type InsightAssertionResponse as f, type Point as g, type ElementTreeNode as h, type AIUsageInfo as i, AIResponseFormat as j, type AISingleElementResponseById as k, type AISingleElementResponseByPosition as l, type AIElementLocatorResponse as m, type AIElementCoordinatesResponse as n, type AIElementResponse as o, type AISectionParseResponse as p, type AISectionLocatorResponse as q, type AIAssertionResponse as r, type EnsureObject as s, type InsightExtractParam as t, type DumpMeta as u, type ReportDumpWithAttributes as v, type InsightDump as w, type PartialInsightDumpFromSDK as x, type ElementById as y, type AgentWaitForOpt as z };
