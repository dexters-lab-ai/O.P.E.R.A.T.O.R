import { NodeType } from '@midscene/shared/constants';
import { ChatCompletionMessageParam } from 'openai/resources';

interface Point {
    left: number;
    top: number;
}
interface Size {
    width: number;
    height: number;
    dpr?: number;
}
type Rect = Point & Size & {
    zoom?: number;
};
declare abstract class BaseElement {
    abstract id: string;
    abstract indexId?: number;
    abstract attributes: {
        nodeType: NodeType;
        [key: string]: string;
    };
    abstract content: string;
    abstract rect: Rect;
    abstract center: [number, number];
    abstract locator?: string;
}
interface ElementTreeNode<ElementType extends BaseElement = BaseElement> {
    node: ElementType | null;
    children: ElementTreeNode<ElementType>[];
}
type AIUsageInfo = Record<string, any> & {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
};
/**
 * openai
 *
 */
declare enum AIResponseFormat {
    JSON = "json_object",
    TEXT = "text"
}
type AISingleElementResponseById = {
    id: string;
    reason?: string;
    text?: string;
};
type AISingleElementResponseByPosition = {
    position?: {
        x: number;
        y: number;
    };
    bbox?: [number, number, number, number];
    reason: string;
    text: string;
};
type AISingleElementResponse = AISingleElementResponseById;
interface AIElementIdResponse {
    elements: {
        id: string;
        reason?: string;
        text?: string;
    }[];
    errors?: string[];
}
interface AIElementCoordinatesResponse {
    bbox: [number, number, number, number];
    errors?: string[];
}
type AIElementResponse = AIElementIdResponse | AIElementCoordinatesResponse;
interface AISectionParseResponse<DataShape> {
    data: DataShape;
    sections?: LiteUISection[];
    errors?: string[];
}
interface AIAssertionResponse {
    pass: boolean;
    thought: string;
}
/**
 * context
 */
declare abstract class UIContext<ElementType extends BaseElement = BaseElement> {
    abstract screenshotBase64: string;
    abstract screenshotBase64WithElementMarker?: string;
    abstract content: ElementType[];
    abstract tree: ElementTreeNode<ElementType>;
    abstract size: Size;
}
/**
 * insight
 */
type CallAIFn = <T>(messages: ChatCompletionMessageParam[]) => Promise<T>;
interface InsightOptions {
    taskInfo?: Omit<InsightTaskInfo, 'durationMs'>;
    aiVendorFn?: CallAIFn;
    generateElement?: (opts: {
        content?: string;
        rect: BaseElement['rect'];
    }) => BaseElement;
}
type EnsureObject<T> = {
    [K in keyof T]: any;
};
type InsightAction = 'locate' | 'extract' | 'assert';
type InsightExtractParam = string | Record<string, string>;
interface InsightTaskInfo {
    durationMs: number;
    formatResponse?: string;
    rawResponse?: string;
    usage?: AIUsageInfo;
}
interface DumpMeta {
    sdkVersion: string;
    logTime: number;
    model_name: string;
    model_description?: string;
}
interface ReportDumpWithAttributes {
    dumpString: string;
    attributes?: Record<string, any>;
}
interface InsightDump extends DumpMeta {
    type: 'locate' | 'extract' | 'assert';
    logId: string;
    context: UIContext;
    userQuery: {
        element?: string;
        dataDemand?: InsightExtractParam;
        sections?: Record<string, string>;
        assertion?: string;
    };
    quickAnswer?: Partial<AISingleElementResponse> | null;
    matchedSection: [];
    matchedElement: BaseElement[];
    data: any;
    assertionPass?: boolean;
    assertionThought?: string;
    taskInfo: InsightTaskInfo;
    error?: string;
}
type PartialInsightDumpFromSDK = Omit<InsightDump, 'sdkVersion' | 'logTime' | 'logId' | 'model_name'>;
type DumpSubscriber = (dump: InsightDump) => Promise<void> | void;
interface LiteUISection {
    name: string;
    description: string;
    sectionCharacteristics: string;
    textIds: string[];
}
type ElementById = (id: string) => BaseElement | null;
type InsightAssertionResponse = AIAssertionResponse & {
    usage?: AIUsageInfo;
};
/**
 * agent
 */
type OnTaskStartTip = (tip: string) => Promise<void> | void;
interface AgentWaitForOpt {
    checkIntervalMs?: number;
    timeoutMs?: number;
}
interface AgentAssertOpt {
    keepRawResponse?: boolean;
}
/**
 * planning
 *
 */
interface PlanningLocateParam {
    id?: string;
    position?: {
        x: number;
        y: number;
    };
    bbox?: [number, number, number, number];
    bbox_2d?: [number, number, number, number];
    prompt: string;
}
interface PlanningAction<ParamType = any> {
    thought?: string;
    type: 'Locate' | 'Tap' | 'Drag' | 'Hover' | 'Input' | 'KeyboardPress' | 'Scroll' | 'Error' | 'ExpectedFalsyCondition' | 'Assert' | 'AssertWithoutThrow' | 'Sleep' | 'Finished';
    param: ParamType;
    locate: PlanningLocateParam | null;
}
interface PlanningAIResponse {
    action?: PlanningAction;
    actions?: PlanningAction[];
    more_actions_needed_by_instruction: boolean;
    log: string;
    sleep?: number;
    error?: string;
    usage?: AIUsageInfo;
    rawResponse?: string;
}
type PlanningActionParamTap = null;
type PlanningActionParamHover = null;
interface PlanningActionParamInputOrKeyPress {
    value: string;
}
interface PlanningActionParamScroll {
    direction: 'down' | 'up' | 'right' | 'left';
    scrollType: 'once' | 'untilBottom' | 'untilTop' | 'untilRight' | 'untilLeft';
    distance: null | number;
}
interface PlanningActionParamAssert {
    assertion: string;
}
interface PlanningActionParamSleep {
    timeMs: number;
}
interface PlanningActionParamError {
    thought: string;
}
type PlanningActionParamWaitFor = ExecutionTaskProgressOptions & AgentWaitForOpt & {
    assertion: string;
};
/**
 * misc
 */
interface Color {
    name: string;
    hex: string;
}
interface BaseAgentParserOpt {
    selector?: string;
    ignoreMarker?: boolean;
}
interface PuppeteerParserOpt extends BaseAgentParserOpt {
}
interface PlaywrightParserOpt extends BaseAgentParserOpt {
}
interface ExecutionTaskProgressOptions {
    onTaskStart?: (task: ExecutionTask) => Promise<void> | void;
}
interface ExecutionRecorderItem {
    type: 'screenshot';
    ts: number;
    screenshot?: string;
    timing?: string;
}
type ExecutionTaskType = 'Planning' | 'Insight' | 'Action' | 'Assertion';
interface ExecutorContext {
    task: ExecutionTask;
    element?: BaseElement | null;
}
interface TaskCacheInfo {
    hit: boolean;
}
interface ExecutionTaskApply<Type extends ExecutionTaskType = any, TaskParam = any, TaskOutput = any, TaskLog = any> {
    type: Type;
    subType?: string;
    param?: TaskParam;
    thought?: string;
    locate: PlanningLocateParam | null;
    quickAnswer?: AISingleElementResponse | null;
    pageContext?: UIContext;
    executor: (param: TaskParam, context: ExecutorContext) => Promise<ExecutionTaskReturn<TaskOutput, TaskLog> | undefined | void> | undefined | void;
}
interface ExecutionTaskReturn<TaskOutput = unknown, TaskLog = unknown> {
    output?: TaskOutput;
    log?: TaskLog;
    recorder?: ExecutionRecorderItem[];
    cache?: TaskCacheInfo;
}
type ExecutionTask<E extends ExecutionTaskApply<any, any, any> = ExecutionTaskApply<any, any, any>> = E & ExecutionTaskReturn<E extends ExecutionTaskApply<any, any, infer TaskOutput, any> ? TaskOutput : unknown, E extends ExecutionTaskApply<any, any, any, infer TaskLog> ? TaskLog : unknown> & {
    status: 'pending' | 'running' | 'finished' | 'failed' | 'cancelled';
    error?: string;
    errorStack?: string;
    timing?: {
        start: number;
        end?: number;
        cost?: number;
        aiCost?: number;
    };
    usage?: AIUsageInfo;
};
interface ExecutionDump extends DumpMeta {
    name: string;
    description?: string;
    tasks: ExecutionTask[];
}
type ExecutionTaskInsightLocateParam = PlanningLocateParam;
interface ExecutionTaskInsightLocateOutput {
    element: BaseElement | null;
}
interface ExecutionTaskInsightDumpLog {
    dump?: InsightDump;
}
type ExecutionTaskInsightLocateApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightLocateParam, ExecutionTaskInsightLocateOutput, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightLocate = ExecutionTask<ExecutionTaskInsightLocateApply>;
interface ExecutionTaskInsightQueryParam {
    dataDemand: InsightExtractParam;
}
interface ExecutionTaskInsightQueryOutput {
    data: any;
}
type ExecutionTaskInsightQueryApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightQueryParam, any, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightQuery = ExecutionTask<ExecutionTaskInsightQueryApply>;
interface ExecutionTaskInsightAssertionParam {
    assertion: string;
}
type ExecutionTaskInsightAssertionApply = ExecutionTaskApply<'Insight', ExecutionTaskInsightAssertionParam, InsightAssertionResponse, ExecutionTaskInsightDumpLog>;
type ExecutionTaskInsightAssertion = ExecutionTask<ExecutionTaskInsightAssertionApply>;
type ExecutionTaskActionApply<ActionParam = any> = ExecutionTaskApply<'Action', ActionParam, void, void>;
type ExecutionTaskAction = ExecutionTask<ExecutionTaskActionApply>;
type ExecutionTaskPlanningApply = ExecutionTaskApply<'Planning', {
    userInstruction: string;
    log?: string;
}, PlanningAIResponse>;
type ExecutionTaskPlanning = ExecutionTask<ExecutionTaskPlanningApply>;
interface GroupedActionDump {
    groupName: string;
    groupDescription?: string;
    executions: ExecutionDump[];
}

export { type ExecutionTaskType as $, type AISingleElementResponse as A, BaseElement as B, type CallAIFn as C, type DumpSubscriber as D, type ExecutionTask as E, type PlanningAction as F, type PlanningAIResponse as G, type PlanningActionParamTap as H, type InsightAction as I, type PlanningActionParamHover as J, type PlanningActionParamInputOrKeyPress as K, type LiteUISection as L, type PlanningActionParamScroll as M, type PlanningActionParamAssert as N, type OnTaskStartTip as O, type Point as P, type PlanningActionParamSleep as Q, type Rect as R, type Size as S, type PlanningActionParamError as T, UIContext as U, type PlanningActionParamWaitFor as V, type Color as W, type BaseAgentParserOpt as X, type PuppeteerParserOpt as Y, type PlaywrightParserOpt as Z, type ExecutionRecorderItem as _, type ExecutionTaskProgressOptions as a, type ExecutorContext as a0, type TaskCacheInfo as a1, type ExecutionTaskReturn as a2, type ExecutionTaskInsightLocateParam as a3, type ExecutionTaskInsightLocateOutput as a4, type ExecutionTaskInsightDumpLog as a5, type ExecutionTaskInsightLocateApply as a6, type ExecutionTaskInsightLocate as a7, type ExecutionTaskInsightQueryParam as a8, type ExecutionTaskInsightQueryOutput as a9, type ExecutionTaskInsightQueryApply as aa, type ExecutionTaskInsightQuery as ab, type ExecutionTaskInsightAssertionParam as ac, type ExecutionTaskInsightAssertionApply as ad, type ExecutionTaskInsightAssertion as ae, type ExecutionTaskActionApply as af, type ExecutionTaskAction as ag, type ExecutionTaskPlanningApply as ah, type ExecutionTaskPlanning as ai, type GroupedActionDump as aj, type ExecutionTaskApply as b, type ExecutionDump as c, type InsightOptions as d, type InsightTaskInfo as e, type InsightAssertionResponse as f, type ElementTreeNode as g, type AIUsageInfo as h, AIResponseFormat as i, type AISingleElementResponseById as j, type AISingleElementResponseByPosition as k, type AIElementIdResponse as l, type AIElementCoordinatesResponse as m, type AIElementResponse as n, type AISectionParseResponse as o, type AIAssertionResponse as p, type EnsureObject as q, type InsightExtractParam as r, type DumpMeta as s, type ReportDumpWithAttributes as t, type InsightDump as u, type PartialInsightDumpFromSDK as v, type ElementById as w, type AgentWaitForOpt as x, type AgentAssertOpt as y, type PlanningLocateParam as z };
