"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }





var _chunkQ4DRRZOEjs = require('./chunk-Q4DRRZOE.js');








var _chunkQVNVYZ3Pjs = require('./chunk-QVNVYZ3P.js');






var _chunkI2I7OU2Ejs = require('./chunk-I2I7OU2E.js');

// src/ai-model/action-executor.ts
var _utils = require('@midscene/shared/utils');
var Executor = class {
  constructor(name, options) {
    this.status = _optionalChain([options, 'optionalAccess', _ => _.tasks]) && options.tasks.length > 0 ? "pending" : "init";
    this.name = name;
    this.tasks = (_optionalChain([options, 'optionalAccess', _2 => _2.tasks]) || []).map(
      (item) => this.markTaskAsPending(item)
    );
    this.onTaskStart = _optionalChain([options, 'optionalAccess', _3 => _3.onTaskStart]);
  }
  markTaskAsPending(task) {
    return {
      status: "pending",
      ...task
    };
  }
  async append(task) {
    _utils.assert.call(void 0, 
      this.status !== "error",
      `executor is in error state, cannot append task
error=${_optionalChain([this, 'access', _4 => _4.latestErrorTask, 'call', _5 => _5(), 'optionalAccess', _6 => _6.error])}
${_optionalChain([this, 'access', _7 => _7.latestErrorTask, 'call', _8 => _8(), 'optionalAccess', _9 => _9.errorStack])}`
    );
    if (Array.isArray(task)) {
      this.tasks.push(...task.map((item) => this.markTaskAsPending(item)));
    } else {
      this.tasks.push(this.markTaskAsPending(task));
    }
    if (this.status !== "running") {
      this.status = "pending";
    }
  }
  async flush() {
    if (this.status === "init" && this.tasks.length > 0) {
      console.warn(
        "illegal state for executor, status is init but tasks are not empty"
      );
    }
    _utils.assert.call(void 0, this.status !== "running", "executor is already running");
    _utils.assert.call(void 0, this.status !== "completed", "executor is already completed");
    _utils.assert.call(void 0, this.status !== "error", "executor is in error state");
    const nextPendingIndex = this.tasks.findIndex(
      (task) => task.status === "pending"
    );
    if (nextPendingIndex < 0) {
      return;
    }
    this.status = "running";
    let taskIndex = nextPendingIndex;
    let successfullyCompleted = true;
    let previousFindOutput;
    while (taskIndex < this.tasks.length) {
      const task = this.tasks[taskIndex];
      _utils.assert.call(void 0, 
        task.status === "pending",
        `task status should be pending, but got: ${task.status}`
      );
      task.timing = {
        start: Date.now()
      };
      try {
        task.status = "running";
        try {
          if (this.onTaskStart) {
            await this.onTaskStart(task);
          }
        } catch (e) {
          console.error("error in onTaskStart", e);
        }
        _utils.assert.call(void 0, 
          ["Insight", "Action", "Planning"].indexOf(task.type) >= 0,
          `unsupported task type: ${task.type}`
        );
        const { executor, param } = task;
        _utils.assert.call(void 0, executor, `executor is required for task type: ${task.type}`);
        let returnValue;
        const executorContext = {
          task,
          element: _optionalChain([previousFindOutput, 'optionalAccess', _10 => _10.element])
        };
        if (task.type === "Insight") {
          _utils.assert.call(void 0, 
            task.subType === "Locate" || task.subType === "Query" || task.subType === "Assert",
            `unsupported insight subType: ${task.subType}`
          );
          returnValue = await task.executor(param, executorContext);
          if (task.subType === "Locate") {
            previousFindOutput = _optionalChain([returnValue, 'optionalAccess', _11 => _11.output]);
          }
        } else if (task.type === "Action" || task.type === "Planning") {
          returnValue = await task.executor(param, executorContext);
        } else {
          console.warn(
            `unsupported task type: ${task.type}, will try to execute it directly`
          );
          returnValue = await task.executor(param, executorContext);
        }
        Object.assign(task, returnValue);
        task.status = "finished";
        task.timing.end = Date.now();
        task.timing.cost = task.timing.end - task.timing.start;
        task.timing.aiCost = _optionalChain([returnValue, 'optionalAccess', _12 => _12.aiCost]) || 0;
        taskIndex++;
      } catch (e) {
        successfullyCompleted = false;
        task.error = _optionalChain([e, 'optionalAccess', _13 => _13.message]) || (typeof e === "string" ? e : "error-without-message");
        task.errorStack = e.stack;
        task.status = "failed";
        task.timing.end = Date.now();
        task.timing.cost = task.timing.end - task.timing.start;
        break;
      }
    }
    for (let i = taskIndex + 1; i < this.tasks.length; i++) {
      this.tasks[i].status = "cancelled";
    }
    if (successfullyCompleted) {
      this.status = "completed";
    } else {
      this.status = "error";
    }
    if (this.tasks.length) {
      const outputIndex = Math.min(taskIndex, this.tasks.length - 1);
      return this.tasks[outputIndex].output;
    }
  }
  isInErrorState() {
    return this.status === "error";
  }
  latestErrorTask() {
    if (this.status !== "error") {
      return null;
    }
    const errorTaskIndex = this.tasks.findIndex(
      (task) => task.status === "failed"
    );
    if (errorTaskIndex >= 0) {
      return this.tasks[errorTaskIndex];
    }
    return null;
  }
  dump() {
    const dumpData = {
      sdkVersion: _chunkQ4DRRZOEjs.getVersion.call(void 0, ),
      model_name: _chunkI2I7OU2Ejs.getAIConfig.call(void 0, _chunkI2I7OU2Ejs.MIDSCENE_MODEL_NAME) || "",
      logTime: Date.now(),
      name: this.name,
      tasks: this.tasks
    };
    return dumpData;
  }
};

// src/insight/index.ts


// src/insight/utils.ts


var logContent = [];
var logIdIndexMap = {};
function emitInsightDump(data, logId, dumpSubscriber) {
  const logDir = _chunkQ4DRRZOEjs.getLogDir.call(void 0, );
  _utils.assert.call(void 0, logDir, "logDir should be set before writing dump file");
  const id = logId || _utils.uuid.call(void 0, );
  let modelDescription = "";
  if (_chunkI2I7OU2Ejs.getAIConfigInBoolean.call(void 0, _chunkI2I7OU2Ejs.MIDSCENE_USE_VLM_UI_TARS)) {
    modelDescription = "vlm-ui-tars mode";
  } else if (_chunkI2I7OU2Ejs.vlLocateMode.call(void 0, )) {
    modelDescription = `${_chunkI2I7OU2Ejs.vlLocateMode.call(void 0, )} mode`;
  }
  const baseData = {
    sdkVersion: _chunkQ4DRRZOEjs.getVersion.call(void 0, ),
    logTime: Date.now(),
    model_name: _chunkI2I7OU2Ejs.getAIConfig.call(void 0, _chunkI2I7OU2Ejs.MIDSCENE_MODEL_NAME) || "",
    model_description: modelDescription
  };
  const finalData = {
    logId: id,
    ...baseData,
    ...data
  };
  _optionalChain([dumpSubscriber, 'optionalCall', _14 => _14(finalData)]);
  const dataString = _chunkQ4DRRZOEjs.stringifyDumpData.call(void 0, finalData, 2);
  if (typeof logIdIndexMap[id] === "number") {
    logContent[logIdIndexMap[id]] = dataString;
  } else {
    const length = logContent.push(dataString);
    logIdIndexMap[id] = length - 1;
  }
  return id;
}

// src/insight/index.ts
var Insight = class {
  constructor(context, opt) {
    this.aiVendorFn = _chunkQVNVYZ3Pjs.callAiFn;
    _utils.assert.call(void 0, context, "context is required for Insight");
    if (typeof context === "function") {
      this.contextRetrieverFn = context;
    } else {
      this.contextRetrieverFn = () => Promise.resolve(context);
    }
    this.generateElement = _optionalChain([opt, 'optionalAccess', _15 => _15.generateElement]);
    if (typeof _optionalChain([opt, 'optionalAccess', _16 => _16.aiVendorFn]) !== "undefined") {
      this.aiVendorFn = opt.aiVendorFn;
    }
    if (typeof _optionalChain([opt, 'optionalAccess', _17 => _17.taskInfo]) !== "undefined") {
      this.taskInfo = opt.taskInfo;
    }
  }
  async locate(query, opt) {
    const { callAI } = opt || {};
    const queryPrompt = typeof query === "string" ? query : query.prompt;
    _utils.assert.call(void 0, 
      queryPrompt || _optionalChain([opt, 'optionalAccess', _18 => _18.quickAnswer]),
      "query or quickAnswer is required for locate"
    );
    const dumpSubscriber = this.onceDumpUpdatedFn;
    this.onceDumpUpdatedFn = void 0;
    const context = await this.contextRetrieverFn("locate");
    const startTime = Date.now();
    const { parseResult, elementById, rawResponse, usage } = await _chunkQVNVYZ3Pjs.AiLocateElement.call(void 0, {
      callAI: callAI || this.aiVendorFn,
      context,
      targetElementDescription: queryPrompt,
      quickAnswer: _optionalChain([opt, 'optionalAccess', _19 => _19.quickAnswer])
    });
    const timeCost = Date.now() - startTime;
    const taskInfo = {
      ...this.taskInfo ? this.taskInfo : {},
      durationMs: timeCost,
      rawResponse: JSON.stringify(rawResponse),
      formatResponse: JSON.stringify(parseResult),
      usage
    };
    let errorLog;
    if (_optionalChain([parseResult, 'access', _20 => _20.errors, 'optionalAccess', _21 => _21.length])) {
      errorLog = `locate - AI response error: 
${parseResult.errors.join("\n")}`;
    }
    const dumpData = {
      type: "locate",
      context,
      userQuery: {
        element: queryPrompt
      },
      quickAnswer: _optionalChain([opt, 'optionalAccess', _22 => _22.quickAnswer]),
      matchedSection: [],
      matchedElement: [],
      data: null,
      taskInfo,
      error: errorLog
    };
    const logId = emitInsightDump(dumpData, void 0, dumpSubscriber);
    if (errorLog) {
      console.error(errorLog);
      throw new Error(errorLog);
    }
    const elements = [];
    parseResult.elements.forEach((item) => {
      if ("id" in item) {
        const element = elementById(item.id);
        if (!element) {
          console.warn(
            `locate: cannot find element id=${item.id}. Maybe an unstable response from AI model`
          );
          return;
        }
        elements.push(element);
      }
    });
    emitInsightDump(
      {
        ...dumpData,
        matchedElement: elements
      },
      logId,
      dumpSubscriber
    );
    if (elements.length >= 2) {
      console.warn(
        `locate: multiple elements found, return the first one. (query: ${queryPrompt})`
      );
      return elements[0];
    }
    if (elements.length === 1) {
      return elements[0];
    }
    return null;
  }
  async extract(dataDemand) {
    _utils.assert.call(void 0, 
      typeof dataDemand === "object" || typeof dataDemand === "string",
      `dataDemand should be object or string, but get ${typeof dataDemand}`
    );
    const dumpSubscriber = this.onceDumpUpdatedFn;
    this.onceDumpUpdatedFn = void 0;
    const context = await this.contextRetrieverFn("extract");
    const startTime = Date.now();
    const { parseResult, usage } = await _chunkQVNVYZ3Pjs.AiExtractElementInfo.call(void 0, {
      context,
      dataQuery: dataDemand
    });
    const timeCost = Date.now() - startTime;
    const taskInfo = {
      ...this.taskInfo ? this.taskInfo : {},
      durationMs: timeCost,
      rawResponse: JSON.stringify(parseResult)
    };
    let errorLog;
    if (_optionalChain([parseResult, 'access', _23 => _23.errors, 'optionalAccess', _24 => _24.length])) {
      errorLog = `AI response error: 
${parseResult.errors.join("\n")}`;
    }
    const dumpData = {
      type: "extract",
      context,
      userQuery: {
        dataDemand
      },
      matchedSection: [],
      matchedElement: [],
      data: null,
      taskInfo,
      error: errorLog
    };
    const logId = emitInsightDump(dumpData, void 0, dumpSubscriber);
    const { data } = parseResult;
    if (errorLog && !data) {
      console.error(errorLog);
      throw new Error(errorLog);
    }
    emitInsightDump(
      {
        ...dumpData,
        matchedSection: [],
        data
      },
      logId,
      dumpSubscriber
    );
    return {
      data,
      usage
    };
  }
  async assert(assertion) {
    if (typeof assertion !== "string") {
      throw new Error(
        "This is the assert method for Midscene, the first argument should be a string. If you want to use the assert method from Node.js, please import it from the Node.js assert module."
      );
    }
    const dumpSubscriber = this.onceDumpUpdatedFn;
    this.onceDumpUpdatedFn = void 0;
    const context = await this.contextRetrieverFn("assert");
    const startTime = Date.now();
    const assertResult = await _chunkQVNVYZ3Pjs.AiAssert.call(void 0, {
      assertion,
      context
    });
    const timeCost = Date.now() - startTime;
    const taskInfo = {
      ...this.taskInfo ? this.taskInfo : {},
      durationMs: timeCost,
      rawResponse: JSON.stringify(assertResult.content)
    };
    const { thought, pass } = assertResult.content;
    const dumpData = {
      type: "assert",
      context,
      userQuery: {
        assertion
      },
      matchedSection: [],
      matchedElement: [],
      data: null,
      taskInfo,
      assertionPass: pass,
      assertionThought: thought,
      error: pass ? void 0 : thought
    };
    emitInsightDump(dumpData, void 0, dumpSubscriber);
    return {
      pass,
      thought,
      usage: assertResult.usage
    };
  }
};

// src/index.ts
var src_default = Insight;














exports.AiAssert = _chunkQVNVYZ3Pjs.AiAssert; exports.AiLocateElement = _chunkQVNVYZ3Pjs.AiLocateElement; exports.Executor = Executor; exports.Insight = Insight; exports.MIDSCENE_MODEL_NAME = _chunkI2I7OU2Ejs.MIDSCENE_MODEL_NAME; exports.default = src_default; exports.describeUserPage = _chunkQVNVYZ3Pjs.describeUserPage; exports.getAIConfig = _chunkI2I7OU2Ejs.getAIConfig; exports.getLogDirByType = _chunkQ4DRRZOEjs.getLogDirByType; exports.getVersion = _chunkQ4DRRZOEjs.getVersion; exports.plan = _chunkQVNVYZ3Pjs.plan; exports.setLogDir = _chunkQ4DRRZOEjs.setLogDir; exports.transformElementPositionToId = _chunkQVNVYZ3Pjs.transformElementPositionToId;

//# sourceMappingURL=index.js.map