// src/tree.ts
function truncateText(text, maxLength = 150) {
  if (typeof text === "undefined") {
    return "";
  }
  if (typeof text === "object") {
    text = JSON.stringify(text);
  }
  if (typeof text === "number") {
    return text.toString();
  }
  if (typeof text === "string" && text.length > maxLength) {
    return `${text.slice(0, maxLength)}...`;
  }
  if (typeof text === "string") {
    return text.trim();
  }
  return "";
}
function trimAttributes(attributes, truncateTextLength) {
  const tailorAttributes = Object.keys(attributes).reduce(
    (res, currentKey) => {
      const attributeVal = attributes[currentKey];
      if (currentKey === "style" || currentKey === "src" || currentKey === "htmlTagName" || currentKey === "nodeType") {
        return res;
      }
      res[currentKey] = truncateText(attributeVal, truncateTextLength);
      return res;
    },
    {}
  );
  return tailorAttributes;
}
var nodeSizeThreshold = 4;
function descriptionOfTree(tree, truncateTextLength, filterNonTextContent = false) {
  const attributesString = (kv) => {
    return Object.entries(kv).map(
      ([key, value]) => `${key}="${truncateText(value, truncateTextLength)}"`
    ).join(" ");
  };
  function buildContentTree(node, indent = 0) {
    let before = "";
    let contentWithIndent = "";
    let after = "";
    let emptyNode = true;
    const indentStr = "  ".repeat(indent);
    let children = "";
    for (let i = 0; i < (node.children || []).length; i++) {
      const childContent = buildContentTree(node.children[i], indent + 1);
      if (childContent) {
        children += `
${childContent}`;
      }
    }
    if (node.node && node.node.rect.width > nodeSizeThreshold && node.node.rect.height > nodeSizeThreshold && (!filterNonTextContent || filterNonTextContent && node.node.content)) {
      emptyNode = false;
      let nodeTypeString;
      if (node.node.attributes?.htmlTagName) {
        nodeTypeString = node.node.attributes.htmlTagName.replace(/[<>]/g, "");
      } else {
        nodeTypeString = node.node.attributes.nodeType.replace(/\sNode$/, "").toLowerCase();
      }
      const markerId = node.node.indexId;
      const markerIdString = typeof markerId !== "undefined" ? `markerId="${markerId}"` : "";
      const rectAttribute = node.node.rect ? {
        left: node.node.rect.left,
        top: node.node.rect.top,
        width: node.node.rect.width,
        height: node.node.rect.height
      } : {};
      before = `<${nodeTypeString} id="${node.node.id}" ${markerIdString} ${attributesString(trimAttributes(node.node.attributes || {}, truncateTextLength))} ${attributesString(rectAttribute)}>`;
      const content = truncateText(node.node.content, truncateTextLength);
      contentWithIndent = content ? `
${indentStr}  ${content}` : "";
      after = `</${nodeTypeString}>`;
    } else if (!filterNonTextContent) {
      if (!children.trim().startsWith("<>")) {
        before = "<>";
        contentWithIndent = "";
        after = "</>";
      }
    }
    if (emptyNode && !children.trim()) {
      return "";
    }
    const result2 = `${indentStr}${before}${contentWithIndent}${children}
${indentStr}${after}`;
    if (result2.trim()) {
      return result2;
    }
    return "";
  }
  const result = buildContentTree(tree);
  return result.replace(/^\s*\n/gm, "");
}
export {
  descriptionOfTree,
  trimAttributes,
  truncateText
};

//# sourceMappingURL=tree.js.map