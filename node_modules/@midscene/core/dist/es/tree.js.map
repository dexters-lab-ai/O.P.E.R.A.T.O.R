{"version":3,"mappings":"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","names":["result"],"ignoreList":[],"sources":["../../src/tree.ts"],"sourcesContent":["import type { BaseElement, ElementTreeNode, Size, UIContext } from '@/types';\n\nexport function truncateText(\n  text: string | number | object | undefined,\n  maxLength = 150,\n) {\n  if (typeof text === 'undefined') {\n    return '';\n  }\n\n  if (typeof text === 'object') {\n    text = JSON.stringify(text);\n  }\n\n  if (typeof text === 'number') {\n    return text.toString();\n  }\n\n  if (typeof text === 'string' && text.length > maxLength) {\n    return `${text.slice(0, maxLength)}...`;\n  }\n\n  if (typeof text === 'string') {\n    return text.trim();\n  }\n\n  return '';\n}\n\nexport function trimAttributes(\n  attributes: Record<string, any>,\n  truncateTextLength?: number,\n) {\n  const tailorAttributes = Object.keys(attributes).reduce(\n    (res, currentKey: string) => {\n      const attributeVal = (attributes as any)[currentKey];\n      if (\n        currentKey === 'style' ||\n        currentKey === 'src' ||\n        currentKey === 'htmlTagName' ||\n        currentKey === 'nodeType'\n      ) {\n        return res;\n      }\n\n      res[currentKey] = truncateText(attributeVal, truncateTextLength);\n      return res;\n    },\n    {} as BaseElement['attributes'],\n  );\n  return tailorAttributes;\n}\n\nconst nodeSizeThreshold = 4;\nexport function descriptionOfTree<\n  ElementType extends BaseElement = BaseElement,\n>(\n  tree: ElementTreeNode<ElementType>,\n  truncateTextLength?: number,\n  filterNonTextContent = false,\n) {\n  const attributesString = (kv: Record<string, any>) => {\n    return Object.entries(kv)\n      .map(\n        ([key, value]) => `${key}=\"${truncateText(value, truncateTextLength)}\"`,\n      )\n      .join(' ');\n  };\n\n  function buildContentTree(\n    node: ElementTreeNode<ElementType>,\n    indent = 0,\n  ): string {\n    let before = '';\n    let contentWithIndent = '';\n    let after = '';\n    let emptyNode = true;\n    const indentStr = '  '.repeat(indent);\n\n    let children = '';\n    for (let i = 0; i < (node.children || []).length; i++) {\n      const childContent = buildContentTree(node.children[i], indent + 1);\n      if (childContent) {\n        children += `\\n${childContent}`;\n      }\n    }\n\n    if (\n      node.node &&\n      node.node.rect.width > nodeSizeThreshold &&\n      node.node.rect.height > nodeSizeThreshold &&\n      (!filterNonTextContent || (filterNonTextContent && node.node.content))\n    ) {\n      emptyNode = false;\n      let nodeTypeString: string;\n      if (node.node.attributes?.htmlTagName) {\n        nodeTypeString = node.node.attributes.htmlTagName.replace(/[<>]/g, '');\n      } else {\n        nodeTypeString = node.node.attributes.nodeType\n          .replace(/\\sNode$/, '')\n          .toLowerCase();\n      }\n      const markerId = node.node.indexId;\n      const markerIdString =\n        typeof markerId !== 'undefined' ? `markerId=\"${markerId}\"` : '';\n      const rectAttribute = node.node.rect\n        ? {\n            left: node.node.rect.left,\n            top: node.node.rect.top,\n            width: node.node.rect.width,\n            height: node.node.rect.height,\n          }\n        : {};\n      before = `<${nodeTypeString} id=\"${node.node.id}\" ${markerIdString} ${attributesString(trimAttributes(node.node.attributes || {}, truncateTextLength))} ${attributesString(rectAttribute)}>`;\n      const content = truncateText(node.node.content, truncateTextLength);\n      contentWithIndent = content ? `\\n${indentStr}  ${content}` : '';\n      after = `</${nodeTypeString}>`;\n    } else if (!filterNonTextContent) {\n      if (!children.trim().startsWith('<>')) {\n        before = '<>';\n        contentWithIndent = '';\n        after = '</>';\n      }\n    }\n\n    if (emptyNode && !children.trim()) {\n      return '';\n    }\n\n    const result = `${indentStr}${before}${contentWithIndent}${children}\\n${indentStr}${after}`;\n    if (result.trim()) {\n      return result;\n    }\n    return '';\n  }\n\n  const result = buildContentTree(tree);\n  return result.replace(/^\\s*\\n/gm, '');\n}\n"]}